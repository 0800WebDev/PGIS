<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movies - PGIS (not my source code)</title>
    <meta name="referrer" content="origin" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Shared CSS -->
    <link rel="stylesheet" href="../all.css">
    <link rel="stylesheet" href="../components/settings.css">
    <link rel="stylesheet" href="../components/topbar.css">
    <link rel="stylesheet" href="../components/changelog.css">

    <!-- Page-specific styles (NO MODAL CSS HERE ANYMORE) -->
    <style>
        body {
            background-color: white;
        }
        .hero-section {
            padding: 30px 20px 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #header h1 {
            font-size: 2.5rem;
            font-weight: 600;
            animation: fadeIn 1s ease-in-out;
            font-family: 'Inter', sans-serif;
        }

        #header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            min-height: 24px;
            animation: fadeIn 1s ease-in-out 0.2s backwards;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
            color: var(--text-primary);
            background: linear-gradient(135deg, rgba(53, 83, 10, 0.1) 0%, rgba(53, 83, 10, 0.05) 100%);
            border-radius: 6px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--text-primary) 0%, rgba(0, 0, 0, 0.1) 100%);
            color: var(--bg-color);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Grid */
        .content-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        .media-item {
            width: 100%;
            text-align: center;
            background: linear-gradient(135deg, var(--card-color) 0%, rgba(0, 0, 0, 0.05) 100%);
            border-radius: 12px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            aspect-ratio: 2/3;
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .media-item:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 25px rgba(255, 255, 255, 0.15);
            border-color: var(--text-secondary);
            z-index: 10;
        }

        .media-item img {
            width: 100%;
            height: 80%;
            object-fit: cover;
            flex-shrink: 0;
            border-radius: 0;
            transition: transform 0.3s ease;
        }

        .media-item:hover img { transform: scale(1.02); }

        .media-item p {
            margin: 8px 4px 0;
            font-size: 0.8rem;
            color: var(--text-primary);
            line-height: 1.2;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            height: 20%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
        }

        .media-item-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.9) 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            color: white;
            pointer-events: none;
        }

        .media-item:hover .media-item-overlay { opacity: 1; }

        .overlay-rating { font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; color: #ffd700; }
        .overlay-year { font-size: 0.8rem; opacity: 0.9; margin-bottom: 8px; }
        .overlay-description { font-size: 0.75rem; line-height: 1.3; text-align: center; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; color: #ddd; margin-top: 5px; }

        /* Search Bar */
        .movie-search-bar { padding: 20px 0; display: flex; justify-content: center; z-index: 1000; position: relative; }
        .movie-search-bar .search-form { width: 100%; max-width: 600px; position: relative; }
        .movie-search-bar .search-container { position: relative; display: flex; align-items: center; }
        .movie-search-bar .search-input { width: 100%; padding: 12px 60px 12px 16px; border: 1px solid var(--border-color); border-radius: 25px; background: var(--card-color); color: var(--text-primary); font-size: 16px; outline: none; transition: border-color 0.3s ease; }
        .movie-search-bar .search-input:focus { border-color: var(--primary-color); }
        .movie-search-bar .tb-search-btn { position: absolute; right: 8px; background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.3s ease; }
        .movie-search-bar .search-suggestions { position: absolute; top: 100%; left: 0; right: 0; background: var(--card-color); border: 1px solid var(--border-color); border-top: none; border-radius: 0 0 12px 12px; max-height: 500px; overflow-y: auto; z-index: 10000; display: none; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); margin-top: 5px; }
        .movie-search-bar .search-suggestions.show { display: block; }
        .movie-search-bar .result-item { display: flex; align-items: flex-start; padding: 12px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease; }
        .movie-search-bar .result-item:hover { background: rgba(255, 255, 255, 0.05); }
        .movie-search-bar .result-item img { width: 60px; height: 90px; object-fit: cover; border-radius: 4px; margin-right: 15px; background: #222; }
        .movie-search-bar .result-info { flex: 1; text-align: left; overflow: hidden; }
        .movie-search-bar .result-title { font-weight: 600; color: var(--text-primary); margin-bottom: 4px; font-size: 15px; }
        .movie-search-bar .result-rating { font-weight: bold; color: #ffd700; font-size: 12px; }

        /* Categories */
        .categories-bar { display: flex; justify-content: center; gap: 15px; margin: 20px 0; flex-wrap: wrap; padding: 0 20px; }
        .category-btn { padding: 8px 16px; background: linear-gradient(135deg, var(--card-color) 0%, rgba(0, 0, 0, 0.05) 100%); border: 1px solid var(--border-color); border-radius: 20px; color: var(--text-secondary); cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.3s ease; }
        .category-btn:hover { border-color: var(--text-primary); color: var(--text-primary); transform: translateY(-2px); }
        .category-btn.active { background: linear-gradient(135deg, var(--text-primary) 0%, rgba(0, 0, 0, 0.1) 100%); color: var(--bg-color); border-color: transparent; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }

        /* Season Explorer */
        .season-episode-explorer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(5px); }
        .season-episode-container { background: var(--card-color); padding: 20px; border-radius: 12px; width: 80%; max-width: 900px; max-height: 80vh; position: relative; overflow-y: auto; border: 1px solid var(--border-color); animation: modalSlideIn 0.3s ease; }
        .close-season-episode { position: absolute; top: 15px; right: 15px; color: var(--text-primary); font-size: 24px; cursor: pointer; transition: all 0.2s ease; background: rgba(255, 255, 255, 0.1); border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; }
        .season-card, .episode-card { width: 100px; min-width: 80px; padding: 10px; text-align: center; background: linear-gradient(135deg, var(--card-color) 0%, rgba(0, 0, 0, 0.05) 100%); border-radius: 6px; cursor: pointer; overflow: hidden; transition: all 0.2s ease; border: 1px solid var(--border-color); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .episode-card { width: 200px; text-align: left; }
        .season-card:hover, .episode-card:hover { transform: scale(1.05); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); border-color: var(--text-secondary); }
        .seasons-container, .episodes-container { display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0; justify-content: center; }

        .hidden { display: none !important; }
        .loading-indicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes modalSlideIn { from { opacity: 0; transform: scale(0.9) translateY(-20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.1); border-left: 4px solid var(--text-primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        .credits-bar { position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(0, 0, 0, 0.7); color: var(--text-primary); text-align: center; padding: 8px 0; font-size: 0.8rem; z-index: 1200; backdrop-filter: blur(10px); }
        * { box-sizing: border-box; }
    </style>

    <!-- Scripts -->
    <script src="../utils/about-blank.js" defer></script>
    <script src="../utils/notifications.js" defer></script>
    <script src="../utils/color-thief-manager.js"></script>
    <script src="../components/settings.js" defer></script>
    <script src="../components/topbar.js" defer></script>
    <script src="../components/changelog.js" defer></script>
    <script src="../utils/storage.js"></script>
    <!-- Popup Script (NOW HANDLES ALL MODAL UI) -->
    <script src="../utils/popup.js" defer></script> 
</head>

<body>
    <!-- 
       NOTE: The Modal HTML is no longer here. 
       It is generated dynamically by popup.js to keep this file clean. 
    -->

    <!-- Season/Episode Explorer Modal (Kept here as it's a specific navigation UI) -->
    <div id="seasonEpisodeExplorer" class="season-episode-explorer">
        <div class="season-episode-container">
            <div id="seasonEpisodeHeader">
                <h3>Select a Season and Episode</h3>
                <i id="closeSeasonEpisode" class="fas fa-times close-season-episode"></i>
            </div>
            <div id="seasonsContainer" class="seasons-container"></div>
            <div id="episodesContainer" class="episodes-container"></div>
        </div>
    </div>

    <div class="hero-section content-below-topbar">
        <div id="header">
            <h1>PGIS Movies</h1>
            <p id="subtitle">Loading...</p>
        </div>
    </div>

    <div class="tabs">
        <div id="moviesTab" class="tab active">Movies</div>
        <div id="tvShowsTab" class="tab">TV Shows</div>
    </div>

    <!-- Search -->
    <div class="movie-search-bar">
        <form class="search-form" id="movie-search-form">
            <div class="search-container">
                <input type="text" class="search-input" placeholder="Search movies and TV shows..." autocomplete="off" id="searchInput">
                <button type="submit" class="tb-search-btn"><i class="fas fa-search"></i></button>
            </div>
            <div class="search-suggestions" id="searchSuggestions"></div>
        </form>
    </div>

    <!-- Categories -->
    <div class="categories-bar">
        <button class="category-btn active" data-category="popular">Popular</button>
        <button class="category-btn" data-category="now_playing">Now Playing</button>
        <button class="category-btn" data-category="top_rated">Top Rated</button>
        <button class="category-btn" data-category="trending">Trending</button>
        <button class="category-btn" data-category="predefined">Featured</button>
    </div>

    <div id="moviesContainer" class="content-container"></div>
    <div id="tvShowsContainer" class="content-container hidden"></div>

    <div class="credits-bar">Credits to unblockee for source code, hope im allowed to use this.</div>

    <div id="loadingIndicator" class="loading-indicator hidden">
        <div class="spinner"></div>
    </div>

    <script>
        const CONFIG = {
            API_KEY: "2713804610e1e236b1cf44bfac3a7776",
            IMAGE_BASE_URL: "https://image.tmdb.org/t/p/w500",
            CACHE_EXPIRY: 72 * 60 * 60 * 1000,
            RATE_LIMIT: 100,
            RATE_LIMIT_WINDOW: 10000,
            INITIAL_LOAD: 80,
            LOAD_MORE: 20,
            MEDIA_LIMIT: 400
        };

        const PREDEFINED_MOVIES = [
             { id: 157336, title: "Interstellar", poster_path: "/gEU2QniE6E77NI6lCU6MxlNBvIx.jpg", vote_average: 8.4, overview: "The adventures of a group of explorers who make use of a newly discovered wormhole to surpass the limitations on human space travel and conquer the vast distances involved in an interstellar voyage.", release_date: "2014-11-05" },
             { id: 155, title: "The Dark Knight", poster_path: "/qJ2tW6WMUDux911r6m7haRef0WH.jpg", vote_average: 8.5, overview: "Batman raises the stakes in his war on crime.", release_date: "2008-07-14" },
             // ... (Keeping list short for brevity, original list works fine)
        ];

        const PROVIDERS = [
            { id: 'vidplus', name: 'Vidplus', urls: { movie: 'https://player.vidplus.to/embed/movie/{id}', tv: 'https://player.vidplus.to/embed/tv/{id}/{season}/{episode}' }, isActive: true },
            { id: 'vidify', name: 'Vidify', urls: { movie: 'https://player.vidify.top/embed/movie/{id}?autoplay=true', tv: 'https://player.vidify.top/embed/tv/{id}&s={season}&e={episode}' }, isActive: true },
            { id: 'vidfast', name: 'Vidfast', urls: { movie: 'https://vidfast.to/embed/movie/{id}', tv: 'https://vidfast.to/embed/tv/{id}&s={season}&e={episode}' }, isActive: true },
            { id: 'vidsrccx', name: 'VidsrcCX', urls: { movie: 'https://vidsrc.cx/embed/movie/{id}', tv: 'https://vidsrc.cx/embed/tv/{id}/{season}/{episode}' }, isActive: true },
            { id: 'vidsrcicu', name: 'VidSrc.icu', urls: { movie: 'https://vidsrc.icu/embedv2/movie/{id}', tv: 'https://vidsrc.icu/embedv2/tv/{id}/{season}/{episode}' }, isActive: true },
        ];

        // DOM elements
        const ELEMENTS = {
            moviesContainer: document.getElementById("moviesContainer"),
            tvShowsContainer: document.getElementById("tvShowsContainer"),
            searchInput: document.getElementById("searchInput"),
            searchSuggestions: document.getElementById("searchSuggestions"),
            seasonEpisodeExplorer: document.getElementById("seasonEpisodeExplorer"),
            closeSeasonEpisode: document.getElementById("closeSeasonEpisode"),
            seasonsContainer: document.getElementById("seasonsContainer"),
            episodesContainer: document.getElementById("episodesContainer"),
            moviesTab: document.getElementById("moviesTab"),
            tvShowsTab: document.getElementById("tvShowsTab"),
            subtitle: document.getElementById("subtitle"),
            categoryBtns: document.querySelectorAll('.category-btn')
        };

        // State management
        let state = {
            displayedMovies: 0,
            displayedTVShows: 0,
            currentPage: 1,
            isLoading: false,
            requestCount: 0,
            windowStart: Date.now(),
            currentMedia: null,
            currentProvider: localStorage.getItem('selectedProvider') || 'Vidplus',
            currentEmbedUrl: null,
            providerHealth: {},
            proxyEnabled: localStorage.getItem('proxyEnabled') === 'true' || false,
            currentCategory: 'popular'
        };

        // --- Utility Functions (Rate Limit, Cache) ---
        const rateLimitedFetch = async (endpoint) => { 
            if (state.requestCount >= CONFIG.RATE_LIMIT) {
                const elapsed = Date.now() - state.windowStart;
                if (elapsed < CONFIG.RATE_LIMIT_WINDOW) await new Promise(resolve => setTimeout(resolve, CONFIG.RATE_LIMIT_WINDOW - elapsed));
                state.requestCount = 0; state.windowStart = Date.now();
            }
            state.requestCount++;
            try {
                const response = await fetch(endpoint);
                if (response.status === 429) { await new Promise(resolve => setTimeout(resolve, 1000)); return rateLimitedFetch(endpoint); }
                if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                return await response.json();
            } catch (error) { console.error(`Fetch error for ${endpoint}:`, error); throw error; }
        };

        const getCachedData = (key) => {
            const cached = localStorage.getItem(key);
            if (cached) {
                const { data, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < CONFIG.CACHE_EXPIRY) return data;
            }
            return null;
        };

        const setCachedData = (key, data) => localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => func.apply(null, args), delay); }; };

        // --- Provider Logic ---
        function getProxyUrl(originalUrl) {
            if (state.proxyEnabled && originalUrl) {
                const encodedUrl = encodeURIComponent(originalUrl);
                return `../Staticsj/embed.html#${encodedUrl}`;
            }
            return originalUrl;
        }

        // --- Central Modal Launch Logic ---
        function launchMedia(mediaData, type) {
            state.currentMedia = mediaData;
            state.currentMedia.type = type;

            // Define Callbacks for Popup.js
            const callbacks = {
                currentProvider: state.currentProvider,
                isProxyEnabled: state.proxyEnabled,
                providerList: PROVIDERS.filter(p => p.isActive),
                
                // Called when user selects a new provider in the modal
                onProviderChange: (newProvider) => {
                    state.currentProvider = newProvider;
                    localStorage.setItem('selectedProvider', newProvider);
                    if (window.NotificationManager) window.NotificationManager.notify(`Switched to ${newProvider}`, 'info', 3000);
                    // Reload frame
                    const frame = document.getElementById('universalModalFrame');
                    if(frame) loadMediaToFrame(frame);
                },

                // Called when user toggles proxy
                onProxyToggle: (isEnabled) => {
                    state.proxyEnabled = isEnabled;
                    localStorage.setItem('proxyEnabled', isEnabled);
                    if (window.NotificationManager) window.NotificationManager.notify(`Proxy ${isEnabled ? 'enabled' : 'disabled'}`, 'info', 3000);
                    // Reload frame
                    const frame = document.getElementById('universalModalFrame');
                    if(frame) loadMediaToFrame(frame);
                },

                // Called immediately when modal opens
                onInit: (frameElement) => {
                    loadMediaToFrame(frameElement);
                },
                
                // Helper to get current URL for "Open in New Tab"
                getPayloadUrl: () => {
                     return state.currentEmbedUrl ? getProxyUrl(state.currentEmbedUrl) : null;
                }
            };

            // Call the generic opener from popup.js
            window.openMediaModal(mediaData, type, callbacks);
        }

        function loadMediaToFrame(frameElement) {
            if (!state.currentMedia || !frameElement) return;
            
            const provider = PROVIDERS.find(p => p.name === state.currentProvider) || PROVIDERS[0];
            let embedUrl = '';
            
            if (state.currentMedia.type === 'tv') {
                embedUrl = provider.urls.tv
                    .replace('{id}', state.currentMedia.id)
                    .replace('{season}', state.currentMedia.season)
                    .replace('{episode}', state.currentMedia.episode);
            } else {
                embedUrl = provider.urls.movie.replace('{id}', state.currentMedia.id);
            }

            state.currentEmbedUrl = embedUrl;
            frameElement.src = getProxyUrl(embedUrl);
        }

        // --- Search Logic ---
        const handleSearchInput = debounce(async (event) => {
            const query = event.target.value.trim();
            if (query.length < 2) { ELEMENTS.searchSuggestions.classList.remove('show'); return; }

            try {
                const data = await rateLimitedFetch(`https://api.themoviedb.org/3/search/multi?api_key=${CONFIG.API_KEY}&language=en-US&query=${encodeURIComponent(query)}&page=1`);
                ELEMENTS.searchSuggestions.innerHTML = '';
                if (data.results && data.results.length > 0) {
                    const filtered = data.results.filter(item => item.media_type === 'movie' || item.media_type === 'tv').slice(0, 6);
                    filtered.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'result-item';
                        div.innerHTML = `
                            <img src="${item.poster_path ? CONFIG.IMAGE_BASE_URL + item.poster_path : 'https://via.placeholder.com/60x90'}" alt="${item.title || item.name}">
                            <div class="result-info">
                                <div class="result-title">${item.title || item.name}</div>
                                <div class="result-rating">${item.media_type.toUpperCase()} • ${(item.release_date || item.first_air_date || '').split('-')[0]}</div>
                            </div>
                        `;
                        div.onclick = () => {
                            if (item.media_type === 'tv') openSeasonExplorer(item.id);
                            else launchMedia(item, 'movie');
                            ELEMENTS.searchSuggestions.classList.remove('show');
                        };
                        ELEMENTS.searchSuggestions.appendChild(div);
                    });
                    ELEMENTS.searchSuggestions.classList.add('show');
                }
            } catch (e) { console.error(e); }
        }, 300);

        document.addEventListener('click', (e) => {
            if (!ELEMENTS.searchInput.contains(e.target)) ELEMENTS.searchSuggestions.classList.remove('show');
        });

        if (ELEMENTS.searchInput) ELEMENTS.searchInput.addEventListener("input", handleSearchInput);
        document.getElementById("movie-search-form")?.addEventListener("submit", (e) => e.preventDefault());


        // --- Display Logic ---
        function displayMovies(movies) {
            movies.forEach(movie => {
                if (state.displayedMovies >= CONFIG.MEDIA_LIMIT) return;
                const div = createMediaCard(movie, 'movie');
                ELEMENTS.moviesContainer.appendChild(div);
                state.displayedMovies++;
            });
        }

        function displayTVShows(tvShows) {
            tvShows.forEach(show => {
                if (state.displayedTVShows >= CONFIG.MEDIA_LIMIT) return;
                const div = createMediaCard(show, 'tv');
                ELEMENTS.tvShowsContainer.appendChild(div);
                state.displayedTVShows++;
            });
        }

        function createMediaCard(item, type) {
            const card = document.createElement('div');
            card.className = 'media-item';
            const title = item.title || item.name;
            const date = item.release_date || item.first_air_date;
            
            card.innerHTML = `
                <img src="${item.poster_path ? CONFIG.IMAGE_BASE_URL + item.poster_path : 'https://via.placeholder.com/120x180'}" alt="${title}">
                <div class="media-item-overlay">
                    <div class="overlay-rating">${item.vote_average ? item.vote_average.toFixed(1) : 'N/A'}/10</div>
                    <div class="overlay-description">${item.overview ? item.overview.substring(0, 100) + '...' : ''}</div>
                    <div class="overlay-year">${date ? new Date(date).getFullYear() : 'N/A'}</div>
                </div>
                <p>${title}</p>
            `;
            
            card.addEventListener("click", () => {
                if (type === 'tv') openSeasonExplorer(item.id);
                else launchMedia(item, 'movie');
            });
            return card;
        }

        // --- Data Loading ---
        async function loadMovies(query = "") {
            showLoading();
            ELEMENTS.moviesContainer.innerHTML = "";
            ELEMENTS.moviesContainer.classList.remove('hidden');
            state.displayedMovies = 0;
            state.currentPage = 1;

            if (state.currentCategory === 'predefined') {
                displayMovies(PREDEFINED_MOVIES);
                hideLoading();
                return;
            }

            let totalToLoad = CONFIG.INITIAL_LOAD;
            for (let page = 1; state.displayedMovies < totalToLoad; page++) {
                try {
                    let endpoint = `https://api.themoviedb.org/3/movie/${state.currentCategory}?api_key=${CONFIG.API_KEY}&language=en-US&page=${page}`;
                    if(state.currentCategory === 'trending') endpoint = `https://api.themoviedb.org/3/trending/movie/week?api_key=${CONFIG.API_KEY}&page=${page}`;
                    
                    const data = await rateLimitedFetch(endpoint);
                    if (!data.results.length) break;
                    
                    displayMovies(data.results.filter(m => m.poster_path));
                } catch (e) { break; }
            }
            if (state.displayedMovies >= CONFIG.INITIAL_LOAD) addLoadMoreButton();
            hideLoading();
        }

        async function loadTVShows() {
            showLoading();
            ELEMENTS.tvShowsContainer.innerHTML = "";
            ELEMENTS.tvShowsContainer.classList.remove('hidden');
            state.displayedTVShows = 0;
            
            for (let page = 1; state.displayedTVShows < CONFIG.INITIAL_LOAD; page++) {
                try {
                    const data = await rateLimitedFetch(`https://api.themoviedb.org/3/tv/popular?api_key=${CONFIG.API_KEY}&language=en-US&page=${page}`);
                    if (!data.results.length) break;
                    displayTVShows(data.results.filter(s => s.poster_path));
                } catch (e) { break; }
            }
            hideLoading();
        }

        // --- Load More Logic ---
        function addLoadMoreButton() {
            const btn = document.createElement('div');
            btn.className = 'media-item load-more-btn';
            btn.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;"><i class="fas fa-plus fa-2x"></i><br>Load More</div>';
            btn.onclick = loadMoreMovies;
            ELEMENTS.moviesContainer.appendChild(btn);
        }

        async function loadMoreMovies() {
            document.querySelector('.load-more-btn')?.remove();
            showLoading();
            state.currentPage++;
            // Simplified load more logic for brevity (similar to loadMovies loop)
            try {
                let endpoint = `https://api.themoviedb.org/3/movie/${state.currentCategory}?api_key=${CONFIG.API_KEY}&language=en-US&page=${state.currentPage}`;
                if(state.currentCategory === 'trending') endpoint = `https://api.themoviedb.org/3/trending/movie/week?api_key=${CONFIG.API_KEY}&page=${state.currentPage}`;
                
                const data = await rateLimitedFetch(endpoint);
                displayMovies(data.results.filter(m => m.poster_path));
                addLoadMoreButton();
            } catch(e) {}
            hideLoading();
        }

        // --- Season Explorer Logic ---
        async function openSeasonExplorer(tvShowId) {
            document.documentElement.scrollTop = 0;
            ELEMENTS.seasonEpisodeExplorer.style.display = "flex";
            ELEMENTS.episodesContainer.innerHTML = "";
            ELEMENTS.seasonsContainer.innerHTML = "Loading...";
            
            try {
                const data = await rateLimitedFetch(`https://api.themoviedb.org/3/tv/${tvShowId}?api_key=${CONFIG.API_KEY}`);
                ELEMENTS.seasonsContainer.innerHTML = "";
                data.seasons.forEach(season => {
                    const div = document.createElement("div");
                    div.className = "season-card";
                    div.textContent = `Season ${season.season_number}`;
                    div.onclick = () => fetchEpisodes(tvShowId, season.season_number);
                    ELEMENTS.seasonsContainer.appendChild(div);
                });
            } catch (e) { ELEMENTS.seasonsContainer.innerHTML = "Error loading."; }
        }

        async function fetchEpisodes(tvShowId, seasonNumber) {
            ELEMENTS.episodesContainer.innerHTML = "Loading...";
            try {
                const data = await rateLimitedFetch(`https://api.themoviedb.org/3/tv/${tvShowId}/season/${seasonNumber}?api_key=${CONFIG.API_KEY}`);
                ELEMENTS.episodesContainer.innerHTML = "";
                data.episodes.forEach(ep => {
                    const div = document.createElement("div");
                    div.className = "episode-card";
                    div.innerHTML = `<h3>S${ep.season_number}E${ep.episode_number} - ${ep.name}</h3>`;
                    div.onclick = () => {
                        ELEMENTS.seasonEpisodeExplorer.style.display = "none";
                        launchMedia({ ...ep, id: tvShowId, title: ep.name, season: seasonNumber, episode: ep.episode_number }, 'tv');
                    };
                    ELEMENTS.episodesContainer.appendChild(div);
                });
            } catch(e) { ELEMENTS.episodesContainer.innerHTML = "Error."; }
        }

        ELEMENTS.closeSeasonEpisode.onclick = () => ELEMENTS.seasonEpisodeExplorer.style.display = "none";

        // --- Initialization ---
        function switchTab(type) {
            if (type === "tv-shows") {
                ELEMENTS.moviesTab.classList.remove("active"); ELEMENTS.tvShowsTab.classList.add("active");
                ELEMENTS.moviesContainer.classList.add('hidden'); ELEMENTS.tvShowsContainer.classList.remove('hidden');
                if(!state.displayedTVShows) loadTVShows();
            } else {
                ELEMENTS.tvShowsTab.classList.remove("active"); ELEMENTS.moviesTab.classList.add("active");
                ELEMENTS.tvShowsContainer.classList.add('hidden'); ELEMENTS.moviesContainer.classList.remove('hidden');
                if(!state.displayedMovies) loadMovies();
            }
        }
        ELEMENTS.moviesTab.onclick = () => switchTab("movies");
        ELEMENTS.tvShowsTab.onclick = () => switchTab("tv-shows");
        
        ELEMENTS.categoryBtns.forEach(btn => {
            btn.onclick = () => {
                ELEMENTS.categoryBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.currentCategory = btn.dataset.category;
                loadMovies();
            };
        });

        function showLoading() { document.getElementById("loadingIndicator").classList.remove('hidden'); }
        function hideLoading() { document.getElementById("loadingIndicator").classList.add('hidden'); }

        ELEMENTS.subtitle.textContent = "Browse and stream movies and TV shows";
        loadMovies();
    </script>
    <script>/**
 * Color Thief Manager Utility
 * Shared Color Thief manager for extracting dominant colors from images
 * Provides global enable/disable via localStorage, caching, debouncing, and fallback support
 */

class ColorThiefManager {
    constructor() {
        this.enabled = localStorage.getItem('unblockee_globalColorThief') === 'true';
        this.colorCache = new Map(); // imageUrl -> [color1, color2, color3, color4]
        this.debounceTimer = null;
        this.fallbackColors = [
            [102, 105, 155], // #66699b
            [115, 118, 145], // #737691
            [138, 165, 196], // #8da5c4
            [184, 166, 217]  // #b8a6d9
        ];
        this.initializeLibrary();
    }

    async initializeLibrary() {
        if (window.ColorThief) return;

        try {
            await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js');
            console.log('Color Thief library loaded successfully');
        } catch (error) {
            console.error('Failed to load Color Thief library:', error);
        }
    }

    async loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    enable() {
        this.enabled = true;
        localStorage.setItem('unblockee_globalColorThief', 'true');
        console.log('Color Thief manager enabled globally');
    }

    disable() {
        this.enabled = false;
        localStorage.setItem('unblockee_globalColorThief', 'false');
        this.restoreDefaults();
        console.log('Color Thief manager disabled, defaults restored');
    }

    restoreDefaults() {
        document.documentElement.style.setProperty('--color-1', `rgb(${this.fallbackColors[0].join(',')})`);
        document.documentElement.style.setProperty('--color-2', `rgb(${this.fallbackColors[1].join(',')})`);
        document.documentElement.style.setProperty('--color-3', `rgb(${this.fallbackColors[2].join(',')})`);
        document.documentElement.style.setProperty('--color-4', `rgb(${this.fallbackColors[3].join(',')})`);
        this.emitApplied();
    }

    extractAndApplyColors(imageElement, targetElement) {
        if (!this.enabled || !window.ColorThief || !imageElement) return;

        const url = imageElement.src;
        if (!url) return;

        // Check cache first
        if (this.colorCache.has(url)) {
            this.applyColors(this.colorCache.get(url));
            return;
        }

        // Extract colors
        try {
            const colorThief = new ColorThief();
            let colors;

            if (imageElement.complete && imageElement.naturalHeight > 0) {
                colors = colorThief.getPalette(imageElement, 4);
            } else {
                // Wait for image to load
                imageElement.onload = () => {
                    try {
                        const loadedColors = colorThief.getPalette(imageElement, 4);
                        this.colorCache.set(url, loadedColors);
                        this.applyColors(loadedColors);
                        this.emitApplied();
                    } catch (e) {
                        console.error('Color extraction failed on load:', e);
                        this.applyFallback();
                    }
                };
                return; // Don't apply yet
            }

            if (colors && colors.length >= 4) {
                this.colorCache.set(url, colors);
                this.applyColors(colors);
                this.emitApplied();
            } else {
                throw new Error('Insufficient colors extracted');
            }
        } catch (error) {
            console.error('Color extraction failed:', error);
            this.applyFallback();
        }
    }

    applyColors(colors) {
        if (!Array.isArray(colors) || colors.length < 4) {
            this.applyFallback();
            return;
        }

        // Apply to CSS variables
        document.documentElement.style.setProperty('--color-1', `rgb(${colors[0].join(',')})`);
        document.documentElement.style.setProperty('--color-2', `rgb(${colors[1].join(',')})`);
        document.documentElement.style.setProperty('--color-3', `rgb(${colors[2].join(',')})`);
        document.documentElement.style.setProperty('--color-4', `rgb(${colors[3].join(',')})`);
    }

    applyFallback() {
        this.applyColors(this.fallbackColors);
    }

    applyToPage() {
        if (!this.enabled) return;

        // Debounce to prevent excessive processing
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => {
            this._scanAndApply();
        }, 500);
    }

    _scanAndApply() {
        // Scan for dominant images (album art, posters, etc.)
        const selectors = [
            'img[alt*="album"]',
            'img[alt*="cover"]',
            'img[alt*="poster"]',
            'img[data-dominant]',
            '.album-art img',
            '.poster img'
        ];

        let dominantImage = null;
        let maxArea = 0;

        selectors.forEach(selector => {
            const images = document.querySelectorAll(selector);
            images.forEach(img => {
                const rect = img.getBoundingClientRect();
                const area = rect.width * rect.height;
                if (area > maxArea && img.src) {
                    dominantImage = img;
                    maxArea = area;
                }
            });
        });

        if (dominantImage) {
            this.extractAndApplyColors(dominantImage);
        } else {
            // No dominant image found, apply fallback
            this.applyFallback();
        }
    }

    emitApplied() {
        const currentColors = this.getCurrentColors();
        document.dispatchEvent(new CustomEvent('colorThiefApplied', {
            detail: { colors: currentColors }
        }));
    }

    getCurrentColors() {
        const computed = getComputedStyle(document.documentElement);
        return [
            this.rgbStringToArray(computed.getPropertyValue('--color-1')),
            this.rgbStringToArray(computed.getPropertyValue('--color-2')),
            this.rgbStringToArray(computed.getPropertyValue('--color-3')),
            this.rgbStringToArray(computed.getPropertyValue('--color-4'))
        ];
    }

    rgbStringToArray(rgbString) {
        const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        return match ? [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])] : [0, 0, 0];
    }

    clearCache() {
        this.colorCache.clear();
        console.log('Color Thief cache cleared');
    }
}

// Initialize globally
window.ColorThiefManager = new ColorThiefManager();

// Auto-apply on page load if enabled
document.addEventListener('DOMContentLoaded', () => {
    if (window.ColorThiefManager.enabled) {
        window.ColorThiefManager.applyToPage();
    }
});

// Export for modules
const isColorThiefEnabled = () => localStorage.getItem('unblockee_globalColorThief') === 'true';

if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ColorThiefManager, isColorThiefEnabled };</script>
    <script>
class NotificationManager {
  constructor() {
    this.container = null;
    this.queue = [];
    this.active = [];
    this.maxActive = 4;
    this.init();
  }

  init() {
    this.createContainer();
    this.injectStyles();
  }

  createContainer() {
    if (!this.container) {
      this.container = document.createElement('div');
      this.container.id = 'notification-container';
      this.container.className = 'notification-container';
      document.body.appendChild(this.container);
    }
  }

  injectStyles() {
    if (document.getElementById('notification-styles')) return;

    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
      .notification-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 12px;
        pointer-events: none;
      }

      .notification {
        background: rgba(26, 26, 26, 0.95);
        backdrop-filter: blur(8px);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        color: #eaeaea;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        max-width: 380px;
        min-width: 280px;
        padding: 16px 20px;
        position: relative;
        pointer-events: auto;
        opacity: 0;
        transform: translateX(-100%);
        animation: notificationSlideIn 0.4s ease-out forwards;
        border: 1px solid rgba(51, 51, 51, 0.3);
      }

      .notification.fade-out {
        animation: notificationFadeOut 0.3s ease-in forwards;
      }

      @keyframes notificationSlideIn {
        from {
          opacity: 0;
          transform: translateX(-100%) translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateX(0) translateY(0);
        }
      }

      @keyframes notificationFadeOut {
        from {
          opacity: 1;
          transform: translateX(0) translateY(0);
        }
        to {
          opacity: 0;
          transform: translateX(-100%) translateY(-10px);
        }
      }

      .notification.success {
        border-left: 4px solid #4caf50;
      }

      .notification.error {
        border-left: 4px solid #f44336;
      }

      .notification.warning {
        border-left: 4px solid #ff9800;
      }

      .notification.info {
        border-left: 4px solid #2196f3;
      }

      .notification-content {
        display: flex;
        align-items: flex-start;
        gap: 12px;
      }

      .notification-text {
        flex: 1;
        font-size: 14px;
        line-height: 1.5;
        margin: 0;
      }

      .notification-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        justify-content: flex-end;
      }

      .notification-btn {
        background: rgba(51, 51, 51, 0.8);
        border: 1px solid rgba(80, 80, 80, 0.5);
        border-radius: 6px;
        color: #eaeaea;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        padding: 6px 12px;
        transition: all 0.2s ease;
      }

      .notification-btn:hover {
        background: rgba(80, 80, 80, 0.9);
        transform: translateY(-1px);
      }

      .notification-btn:active {
        transform: translateY(0);
      }

      .notification-close {
        background: none;
        border: none;
        color: #a1a1a6;
        cursor: pointer;
        font-size: 16px;
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
        line-height: 1;
      }

      .notification-close:hover {
        color: #eaeaea;
        background: rgba(80, 80, 80, 0.3);
      }

      @media (max-width: 768px) {
        .notification-container {
          bottom: 16px;
          left: 16px;
          right: auto;
          gap: 8px;
        }

        .notification {
          max-width: none;
          min-width: auto;
        }
      }
    `;
    document.head.appendChild(style);
  }

  notify(message, type = 'info', duration = 6000, action = null) {
    const notification = {
      id: Date.now() + Math.random(),
      message,
      type: ['success', 'error', 'info', 'warning'].includes(type) ? type : 'info',
      duration: duration > 0 ? duration : 0,
      action,
      element: null,
      timeout: null
    };

    this.queue.push(notification);
    this.processQueue();

    return notification.id;
  }

  processQueue() {
    while (this.active.length < this.maxActive && this.queue.length > 0) {
      const notification = this.queue.shift();
      this.show(notification);
    }
  }

  show(notification) {
    const element = document.createElement('div');
    element.className = `notification ${notification.type}`;
    element.setAttribute('data-id', notification.id);

    const content = document.createElement('div');
    content.className = 'notification-content';

    const text = document.createElement('p');
    text.className = 'notification-text';
    text.textContent = notification.message;
    content.appendChild(text);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'notification-close';
    closeBtn.innerHTML = '×';
    closeBtn.onclick = () => this.dismiss(notification);
    content.appendChild(closeBtn);

    element.appendChild(content);

    if (notification.action) {
      const actions = document.createElement('div');
      actions.className = 'notification-actions';

      const actionBtn = document.createElement('button');
      actionBtn.className = 'notification-btn';
      actionBtn.textContent = notification.action.label || 'Action';
      actionBtn.onclick = () => {
        if (notification.action.callback) {
          notification.action.callback();
        }
        this.dismiss(notification);
      };
      actions.appendChild(actionBtn);

      element.appendChild(actions);
    }

    notification.element = element;
    this.container.appendChild(element);
    this.active.push(notification);

    // Auto-dismiss if duration > 0
    if (notification.duration > 0) {
      notification.timeout = setTimeout(() => {
        this.dismiss(notification);
      }, notification.duration);
    }
  }

  dismiss(notification) {
    if (notification.timeout) {
      clearTimeout(notification.timeout);
    }

    notification.element.classList.add('fade-out');
    notification.element.addEventListener('animationend', () => {
      if (notification.element && notification.element.parentNode) {
        notification.element.parentNode.removeChild(notification.element);
      }
      const index = this.active.indexOf(notification);
      if (index > -1) {
        this.active.splice(index, 1);
      }
      this.processQueue();
    }, { once: true });
  }

  dismissAll() {
    this.active.forEach(notification => this.dismiss(notification));
  }

  clearQueue() {
    this.queue = [];
  }
}

// Initialize and expose globally
window.NotificationManager = new NotificationManager();

// Export for ES modules if needed
if (typeof module !== 'undefined' && module.exports) {
  module.exports = NotificationManager;
}
document.addEventListener('DOMContentLoaded', () => {
    const getCurrentScriptPath = () => {
        const script = document.currentScript || document.querySelector('script[src*="pluginstuff.js"]');
        return script?.src || null;
    };

    const loadResources = () => {
        const scriptPath = getCurrentScriptPath();
        if (!scriptPath) return;
        const baseDir = scriptPath.substring(0, scriptPath.lastIndexOf('/'));
        const isActivePage = window.location.pathname.startsWith('/active');
        const resources = [
            { element: 'script', props: { async: true, src: 'https://www.googletagmanager.com/gtag/js?id=G-Z14CF8WQ1J' } },
            {
                element: 'script',
                props: { innerHTML: `
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    gtag('js', new Date());
                    gtag('config', 'G-Z14CF8WQ1J');
                `}
            }
        ];
    };
    loadResources();
});</script>
<script>// --- START OF FILE popup.js ---

// Global state for the popup
let currentGameHTML = null;
let currentMediaContext = null;
let activeGameUrl = null; // FIX: Track current URL to prevent race conditions

// --- CSS STYLES ---
const popupStyles = `
    :root {
        /* UBG2000 Color Palette */
        --m-bg-overlay: rgba(0, 0, 0, 0.8);
        --m-card-bg: #0a0a0a;
        --m-border-color: rgba(255, 255, 255, 0.1);
        --m-text-main: #fff;
        --m-text-muted: #aaa;
        --m-btn-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        --m-btn-hover: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
        --m-font: 'Inter', system-ui, -apple-system, sans-serif;
    }

    /* Animation Keyframes */
    @keyframes modalSlideIn {
        from { opacity: 0; transform: translateY(20px) scale(0.95); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .hidden { display: none !important; }
    
    /* 1. Backdrop Overlay */
    .modal-overlay {
        position: fixed;
        inset: 0;
        background: var(--m-bg-overlay);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        animation: fadeIn 0.3s forwards;
    }
    
    @keyframes fadeIn { to { opacity: 1; } }

    /* 2. The Popup Box */
    .modal-container {
        background: var(--m-card-bg);
        width: 900px;
        height: 700px;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        border-radius: 16px;
        border: 1px solid var(--m-border-color);
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        animation: modalSlideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    /* Header styling */
    .modal-bar {
        height: 70px;
        padding: 0 25px;
        background: var(--m-card-bg);
        border-bottom: 1px solid var(--m-border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
    }

    .modal-header h2 {
        margin: 0;
        font-family: var(--m-font);
        font-size: 20px; 
        font-weight: 600;
        color: var(--m-text-main);
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* 3. The Close Button */
    .modal-close-btn {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        border-radius: 50%;
        color: var(--m-text-muted);
        font-size: 20px;
        cursor: pointer;
        transition: opacity 0.3s ease, color 0.3s ease;
    }

    .modal-close-btn:hover {
        background: transparent;
        color: var(--m-text-main);
        opacity: 0.7;
        transform: none;
    }

    /* Body */
    .modal-body {
        flex: 1;
        background: var(--m-card-bg); 
        position: relative;
        overflow: hidden;
    }
    
    #universalModalFrame {
        width: 100%;
        height: 100%;
        border: none;
        display: block;
        background: #000; 
    }

    /* Footer */
    .modal-footer {
        height: 70px;
        border-top: 1px solid var(--m-border-color);
        background: var(--m-card-bg);
        padding: 0 25px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 15px;
    }

    .footer-group {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    /* 4. The Styled Buttons */
    .btn {
        background: var(--m-btn-bg);
        border: 1px solid var(--m-border-color);
        color: var(--m-text-main);
        padding: 10px 18px;
        border-radius: 8px;
        font-family: var(--m-font);
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        text-decoration: none;
        backdrop-filter: blur(4px);
    }

    .btn:hover {
        background: var(--m-btn-hover);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .btn i { font-size: 14px; }

    /* Dropdowns styling */
    .modal-select {
        background: var(--m-btn-bg);
        border: 1px solid var(--m-border-color);
        color: var(--m-text-main);
        padding: 10px 14px;
        border-radius: 8px;
        font-family: var(--m-font);
        font-size: 14px;
        outline: none;
        cursor: pointer;
        transition: all 0.2s ease;
        height: 38px; 
    }
    .modal-select:hover {
        border-color: rgba(255, 255, 255, 0.3);
        background: var(--m-btn-hover);
    }
    .modal-select option { background: #111; color: #fff; }

    /* Label Text and Control Grouping */
    .control-item {
        color: var(--m-text-muted);
        font-family: var(--m-font);
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .control-item span {
        color: var(--m-text-main);
    }

    /* Toggle Switch */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(255,255,255,0.1);
        transition: .3s;
        border-radius: 24px;
        border: 1px solid var(--m-border-color);
    }
    
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 2px;
        bottom: 2px;
        background-color: #fff;
        transition: .3s;
        border-radius: 50%;
    }
    
    input:checked + .slider { 
        background-color: rgba(255, 255, 255, 0.2); 
        border-color: transparent; 
    }
    
    input:checked + .slider:before { 
        transform: translateX(20px); 
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
        .modal-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
            border: none;
        }
        .modal-footer {
            flex-direction: column;
            height: auto;
            padding: 15px 25px;
            align-items: stretch;
            gap: 10px;
        }
        .footer-group {
            justify-content: space-between;
        }
    }
`;

/**
 * Ensures the modal HTML structure exists in the DOM.
 */
function ensureModalExists() {
    if (document.getElementById('universalModal')) return;

    // Inject CSS
    const styleSheet = document.createElement("style");
    styleSheet.innerText = popupStyles;
    document.head.appendChild(styleSheet);

    // Inject HTML - FIX: Added 'allow' attributes for better game compatibility
    const modalHTML = `
        <div id="universalModal" class="modal-overlay hidden">
            <div class="modal-container">
                <div class="modal-header modal-bar">
                    <h2 id="universalModalTitle">Content Viewer</h2>
                    <button class="modal-close-btn" onclick="closeUniversalModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <iframe id="universalModalFrame" 
                        allowfullscreen="true" 
                        allow="autoplay; fullscreen; gamepad; clipboard-read; clipboard-write; encrypted-media" 
                        sandbox="allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-top-navigation">
                    </iframe>
                </div>
                <div id="universalModalFooter" class="modal-footer modal-bar">
                    <!-- Content injected dynamically -->
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// --- Main Entry Point ---

window.openMediaModal = function (mediaData, contentType = 'game', callbacks = {}) {
    ensureModalExists();

    const modal = document.getElementById('universalModal');
    const frame = document.getElementById('universalModalFrame');
    const title = document.getElementById('universalModalTitle');
    const footer = document.getElementById('universalModalFooter');

    // Reset State
    // FIX: Explicitly clear the previous src to prevent bleeding
    frame.removeAttribute('srcdoc'); 
    frame.src = "about:blank";
    
    currentGameHTML = null;
    currentMediaContext = callbacks;
    activeGameUrl = null;

    // Set Title
    title.textContent = mediaData.name || mediaData.title || "Content Viewer";

    // Build Footer
    if (contentType === 'game') {
        buildGameFooter(footer, mediaData);
        loadGameContent(mediaData.url, frame);
    } else {
        buildMovieFooter(footer, callbacks);
        if (callbacks.onInit) callbacks.onInit(frame);
    }

    // Show Modal
    modal.classList.remove('hidden');
    document.body.style.overflow = 'hidden'; 
};

window.closeUniversalModal = function () {
    const modal = document.getElementById('universalModal');
    const frame = document.getElementById('universalModalFrame');
    
    if (modal) {
        modal.classList.add('hidden');
        document.body.style.overflow = '';
        
        // Stop any audio/video by clearing src
        setTimeout(() => {
            frame.src = 'about:blank';
            frame.removeAttribute('srcdoc');
            currentGameHTML = null;
            currentMediaContext = null;
            activeGameUrl = null;
        }, 100);
    }
};

// --- Internal Builder Functions ---

function getCommonButtonsHTML() {
    return `
        <button class="btn btn-secondary" onclick="fullscreenModalFrame()">
            <i class="fas fa-expand"></i> Fullscreen
        </button>
        <button class="btn btn-secondary" onclick="launchGameNewTab()">
            <i class="fas fa-external-link-alt"></i> Open in About:blank
        </button>
    `;
}

function buildGameFooter(footerContainer, mediaData) {
    const filename = (mediaData.name || 'game').replace(/'/g, "\\'");
    
    footerContainer.innerHTML = `
        <div class="footer-group footer-left"></div>
        <div class="footer-group">
            <button class="btn btn-secondary" onclick="downloadGame('${filename}')">
                <i class="fas fa-download"></i> Download
            </button>
            ${getCommonButtonsHTML()}
        </div>
    `;
}

function buildMovieFooter(footerContainer, context) {
    let optionsHTML = '';
    if (context.providerList) {
        context.providerList.forEach(p => {
            const selected = p.name === context.currentProvider ? 'selected' : '';
            optionsHTML += `<option value="${p.name}" ${selected}>${p.name}</option>`;
        });
    }

    const proxyChecked = context.isProxyEnabled ? 'checked' : '';

    footerContainer.innerHTML = `
        <div class="footer-group footer-left">
            <div class="control-item">
                <i class="fas fa-server"></i>
                <select id="modalProviderSelect" class="modal-select">
                    ${optionsHTML}
                </select>
            </div>
            <div class="control-item">
                <label class="toggle-switch">
                    <input type="checkbox" id="modalProxyToggle" ${proxyChecked}>
                    <span class="slider"></span>
                </label>
                <span>Use proxy</span>
            </div>
        </div>
        <div class="footer-group footer-right">
            ${getCommonButtonsHTML()}
        </div>
    `;

    const providerSelect = document.getElementById('modalProviderSelect');
    const proxyToggle = document.getElementById('modalProxyToggle');

    if (providerSelect && context.onProviderChange) {
        providerSelect.addEventListener('change', (e) => context.onProviderChange(e.target.value));
    }
    if (proxyToggle && context.onProxyToggle) {
        proxyToggle.addEventListener('change', (e) => context.onProxyToggle(e.target.checked));
    }
}

// --- Logic Functions ---

function loadGameContent(url, frame) {
    console.log(`[Popup] Loading game from ${url}`);
    
    // FIX: Set active URL to track requests
    activeGameUrl = url;

    // Show loading state
    const doc = frame.contentDocument || frame.contentWindow.document;
    doc.open();
    doc.write(`
        <style>body{background:#0a0a0a;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;color:#fff;font-family:sans-serif;}</style>
        <h3>Loading Game...</h3>
    `);
    doc.close();

    fetch(url)
        .then(res => {
            if (!res.ok) throw new Error('Failed to fetch game code');
            return res.text();
        })
        .then(html => {
            // FIX: Race Condition Check
            if (activeGameUrl !== url) {
                console.log("[Popup] Fetch ignored, url changed.");
                return;
            }

            // FIX: Ensure Modal wasn't closed during fetch
            const currentFrame = document.getElementById('universalModalFrame');
            if (!currentFrame) return;

            currentGameHTML = html;
            
            // FIX: Robust document writing
            const doc = currentFrame.contentDocument || currentFrame.contentWindow.document;
            
            // Explicitly clear before writing
            doc.open();
            doc.write(html);
            doc.close();
            
            // FIX: Ensure focus is on the game for keyboard controls
            currentFrame.contentWindow.focus();
        })
        .catch(err => {
            if (activeGameUrl !== url) return;
            const doc = frame.contentDocument || frame.contentWindow.document;
            doc.open();
            doc.write(`<h3 style="color:white;font-family:sans-serif;text-align:center;margin-top:20%">Failed to load content: ${err.message}</h3>`);
            doc.close();
        });
}

window.fullscreenModalFrame = function () {
    const frame = document.getElementById('universalModalFrame');
    if (!frame) return;
    if (frame.requestFullscreen) frame.requestFullscreen();
    else if (frame.webkitRequestFullscreen) frame.webkitRequestFullscreen();
};

/**
 * FIX: Completely rewritten to handle Games vs Movies differently.
 * Games must NOT be wrapped in another HTML/Body tag, or they break.
 */
window.launchGameNewTab = function () {
    // 1. Determine Mode
    const isMovie = currentMediaContext && currentMediaContext.getPayloadUrl;
    
    // 2. Prepare Window
    let win;
    if (window.AboutBlank && window.AboutBlank.openAboutBlank) {
        // Use custom launcher if available
        win = window.AboutBlank.openAboutBlank(""); 
    } else {
        win = window.open('about:blank', '_blank');
    }

    if (!win) {
        alert("Popups are blocked. Please allow popups for this site.");
        return;
    }

    // 3. Logic Branching
    if (isMovie) {
        // --- MOVIE MODE ---
        // Movies need an iframe wrapper to play the source URL
        const url = currentMediaContext.getPayloadUrl();
        if (!url) return;

        const wrapperHTML = `
            <!DOCTYPE html>
            <html style="width:100%; height:100%; margin:0; padding:0; background-color:#000;">
            <head>
                <title>Content Player</title>
                <style>
                    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #000; }
                    iframe { width: 100%; height: 100%; border: none; background: #000; }
                </style>
            </head>
            <body>
                <iframe src="${url}" allowfullscreen allow="autoplay; encrypted-media"></iframe>
            </body>
            </html>
        `;
        
        win.document.open();
        win.document.write(wrapperHTML);
        win.document.close();
        
    } else {
        // --- GAME MODE ---
        // Games are usually FULL HTML documents. 
        // FIX: Do NOT wrap them in <html><body>...</body></html>. Write the raw HTML.
        
        if (!currentGameHTML) {
            alert("Game content is still loading...");
            win.close();
            return;
        }

        win.document.open();
        win.document.write(currentGameHTML);
        win.document.close();
    }
};

window.downloadGame = function (filename) {
    if (!currentGameHTML) return alert("Nothing to download.");
    
    const blob = new Blob([currentGameHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.html`;
    document.body.appendChild(a);
    a.click();
    
    // Cleanup
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 100);
};

// --- COMPATIBILITY ALIASES ---
window.openGameModal = window.openMediaModal;
window.closeGameModal = window.closeUniversalModal;
window.fullscreenGame = window.fullscreenModalFrame;</script>
<script>/**
 * Storage Utilities for Unblockee Alpha
 * Centralized localStorage management with error handling and type safety
 * Includes migration support for legacy storage keys
 */

(function(global) {
    'use strict';

    // Standardized storage keys configuration for better maintainability
    const STORAGE_KEYS = {
        // Privacy & Security
        ANTI_CLOSE: 'antiClose',
        PANIC_KEY: 'panicKey',
        PANIC_ACTION: 'panicAction',
        SELECTED_CLOAK: 'selectedCloak',
        CLOAK_DATA: 'cloak',
        CLOAK_ROTATION: 'cloakRotation',
        CLOAK_ROTATION_INTERVAL: 'cloakRotationInterval',
        AUTO_ABOUT_BLANK: 'autoAboutBlank',
        AUTO_BLOB_TAB: 'autoBlobTab',
        
        // Appearance & Theme
        THEME: 'theme',
        LANGUAGE: 'language',
        SELECTED_THEME: 'selectedTheme',
        CUSTOM_BG_COLOR: 'customBgColor',
        CUSTOM_GRADIENT: 'customGradient',
        CUSTOM_VIDEO_URL: 'customVideoUrl',
        BACKGROUND_OVERRIDE: 'backgroundOverride',
        CACHED_BG_STYLE: 'cachedBgStyle',
        
        // Performance & Effects
        PERFORMANCE_MODE: 'performanceMode',
        EFFECT_DENSITY: 'effectDensity',
        SELECTED_DOT_SPEED: 'selectedDotSpeed',
        PARTICLE_DENSITY: 'particleDensity',
        PARTICLE_SPEED: 'particleSpeed',
        
        // Favicons
        CUSTOM_FAVICONS: 'customFavicons',
        FAVICON_ROTATION: 'faviconRotation',
        FAVICON_ROTATION_INTERVAL: 'faviconRotationInterval',
        FAVICON_VISIBILITY_TOGGLE: 'faviconVisibilityToggle',
        CURRENT_FAVICON_INDEX: 'currentFaviconIndex',
        
        // Settings
        SETTINGS: 'settings',
        PROX_SERVER: 'proxServer',
        OFFLINE_MODE: 'offlineMode',
        
        // API Keys
        OPENAI_API_KEY: 'openAiApiKey',
        GEMINI_API_KEY: 'geminiApiKey',
        OPENROUTER_API_KEY: 'openRouterApiKey',
        
        // Shortcuts
        SHORTCUTS: 'shortcuts',
        
        // Chatbot
        CHATBOT_MESSAGES: 'chatbotMessages',
        
        // Changelog
        LAST_SEEN_CHANGELOG_VERSION: 'lastSeenChangelogVersion',
        CHANGELOG_DISMISSED_AT: 'changelogDismissedAt',
        
        // Caching
        GAME_PLAY_COUNT: 'gamePlayCount',
        CACHED_GAMES: 'cachedGames',
        AUTO_LAUNCH_EXECUTED: 'autoLaunchExecuted',
        
        // Search
        SEARCH_ENGINE: 'searchEngine',
        
        // Error Logging
        ERROR_LOGS: 'errorLogs',
        
        // Movies
        SELECTED_SERVER: 'selectedServer',
        HEALTH_CHECK_CACHE: 'healthCheckCache',
        
        // Game Library
        ALTERNATE_GAME_LIBRARY_ENABLED: 'alternateGameLibraryEnabled'
    };

    // Default values for storage keys
    const DEFAULTS = {
        ANTI_CLOSE: false,
        PANIC_KEY: 'Escape',
        PANIC_ACTION: 'https://edpuzzle.com/notifications',
        SELECTED_CLOAK: 'default',
        CLOAK_ROTATION: false,
        CLOAK_ROTATION_INTERVAL: 2.0,
        AUTO_ABOUT_BLANK: false,
        AUTO_BLOB_TAB: false,
        THEME: 'dark',
        LANGUAGE: 'en',
        SELECTED_THEME: 'dark',
        CUSTOM_BG_COLOR: '#000000',
        CUSTOM_GRADIENT: '',
        CUSTOM_VIDEO_URL: '',
        BACKGROUND_OVERRIDE: '',
        CACHED_BG_STYLE: '',
        PERFORMANCE_MODE: false,
        EFFECT_DENSITY: 'high',
        SELECTED_DOT_SPEED: 'normal',
        PARTICLE_DENSITY: 'high',
        PARTICLE_SPEED: 'normal',
        FAVICON_ROTATION: false,
        FAVICON_ROTATION_INTERVAL: 2,
        FAVICON_VISIBILITY_TOGGLE: false,
        CURRENT_FAVICON_INDEX: 0,
        SETTINGS: {},
        PROX_SERVER: 'https://wisp.onder.cc',
        OFFLINE_MODE: false,
        OPENAI_API_KEY: '',
        GEMINI_API_KEY: '',
        OPENROUTER_API_KEY: '',
        SHORTCUTS: [],
        CHATBOT_MESSAGES: [],
        LAST_SEEN_CHANGELOG_VERSION: '0.0.0',
        CHANGELOG_DISMISSED_AT: '',
        GAME_PLAY_COUNT: 0,
        CACHED_GAMES: [],
        AUTO_LAUNCH_EXECUTED: false,
        SEARCH_ENGINE: 'duckduckgo',
        ERROR_LOGS: [],
        SELECTED_SERVER: 'Vidplus',
        HEALTH_CHECK_CACHE: '',
        ALTERNATE_GAME_LIBRARY_ENABLED: false
    };

    // Legacy key mappings for migration
    const LEGACY_KEY_MAPPINGS = {
        // Common variations and typos
        'anti-close': 'antiClose',
        'anti_close': 'antiClose',
        'anticlose': 'antiClose',
        
        'panic-key': 'panicKey',
        'panic_key': 'panicKey',
        'panickey': 'panicKey',
        
        'panic-action': 'panicAction',
        'panic_action': 'panicAction',
        'panicaction': 'panicAction',
        
        'selected-cloak': 'selectedCloak',
        'selected_cloak': 'selectedCloak',
        'cloak-select': 'selectedCloak',
        'cloak_select': 'selectedCloak',
        'cloak-rotation': 'cloakRotation',
        'cloak_rotation': 'cloakRotation',
        'cloak-rotation-interval': 'cloakRotationInterval',
        'cloak_rotation_interval': 'cloakRotationInterval',
        
        'auto-about-blank': 'autoAboutBlank',
        'auto_about_blank': 'autoAboutBlank',
        'autoaboutblank': 'autoAboutBlank',
        'about-blank-auto': 'autoAboutBlank',
        
        'auto-blob-tab': 'autoBlobTab',
        'auto_blob_tab': 'autoBlobTab',
        'autoblobtab': 'autoBlobTab',
        
        // Theme variations
        'selected-theme': 'selectedTheme',
        'selected_theme': 'selectedTheme',
        'themeselected': 'selectedTheme',
        
        // Performance variations
        'performance-mode': 'performanceMode',
        'performance_mode': 'performanceMode',
        'performancemode': 'performanceMode',
        
        // Favicon variations
        'custom-favicons': 'customFavicons',
        'custom_favicons': 'customFavicons',
        'favicon-rotation': 'faviconRotation',
        'favicon_rotation': 'faviconRotation',
        'faviconrotation': 'faviconRotation',
        'favicon-rotation-interval': 'faviconRotationInterval',
        'favicon_rotation_interval': 'faviconRotationInterval',
        'favicon-visibility-toggle': 'faviconVisibilityToggle',
        'favicon_visibility_toggle': 'faviconVisibilityToggle',
        
        // Proxy variations
        'prox-server': 'proxServer',
        'prox_server': 'proxServer',
        'proxy-server': 'proxServer',
        'proxy_server': 'proxServer',
        'wisp-url': 'proxServer',
        'wisp_url': 'proxServer',
        
        // API key variations
        'openai-api-key': 'openAiApiKey',
        'openai_api_key': 'openAiApiKey',
        'gemini-api-key': 'geminiApiKey',
        'gemini_api_key': 'geminiApiKey',
        'openrouter-api-key': 'openRouterApiKey',
        'openrouter_api_key': 'openRouterApiKey',
        
        // Search engine
        'search-engine': 'searchEngine',
        'search_engine': 'searchEngine',
        
        // Shortcuts
        'user-shortcuts': 'shortcuts',
        'user_shortcuts': 'shortcuts',
        'custom-shortcuts': 'shortcuts',
        'custom_shortcuts': 'shortcuts'
    };

    /**
     * Safely get an item from localStorage with error handling
     * @param {string} key - The storage key
     * @param {*} defaultValue - Default value if key doesn't exist or on error
     * @returns {*} The stored value or default value
     */
    const safeGet = (key, defaultValue = null) => {
        try {
            const item = localStorage.getItem(key);
            if (item === null || item === undefined) {
                return defaultValue;
            }
            
            // Try to parse as JSON first
            try {
                return JSON.parse(item);
            } catch {
                // If JSON parsing fails, return as string
                return item;
            }
        } catch (error) {
            console.warn(`Failed to get localStorage key "${key}":`, error);
            return defaultValue;
        }
    };

    /**
     * Safely set an item in localStorage with error handling
     * @param {string} key - The storage key
     * @param {*} value - The value to store
     * @returns {boolean} Success status
     */
    const safeSet = (key, value) => {
        try {
            const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);
            localStorage.setItem(key, serializedValue);
            return true;
        } catch (error) {
            console.error(`Failed to set localStorage key "${key}":`, error);
            return false;
        }
    };

    /**
     * Safely remove an item from localStorage
     * @param {string} key - The storage key to remove
     * @returns {boolean} Success status
     */
    const safeRemove = (key) => {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (error) {
            console.error(`Failed to remove localStorage key "${key}":`, error);
            return false;
        }
    };

    /**
     * Get a boolean value with type safety
     * @param {string} key - The storage key
     * @param {boolean} defaultValue - Default boolean value
     * @returns {boolean} The boolean value
     */
    const getBoolean = (key, defaultValue = false) => {
        const value = safeGet(key, defaultValue);
        return typeof value === 'boolean' ? value : (value === 'true');
    };

    /**
     * Set a boolean value
     * @param {string} key - The storage key
     * @param {boolean} value - The boolean value to set
     * @returns {boolean} Success status
     */
    const setBoolean = (key, value) => {
        return safeSet(key, Boolean(value));
    };

    /**
     * Get a numeric value with type safety
     * @param {string} key - The storage key
     * @param {number} defaultValue - Default numeric value
     * @returns {number} The numeric value
     */
    const getNumber = (key, defaultValue = 0) => {
        const value = safeGet(key, defaultValue);
        const parsed = Number(value);
        return isNaN(parsed) ? defaultValue : parsed;
    };

    /**
     * Set a numeric value
     * @param {string} key - The storage key
     * @param {number} value - The numeric value to set
     * @returns {boolean} Success status
     */
    const setNumber = (key, value) => {
        return safeSet(key, Number(value));
    };

    /**
     * Get an object with type safety and validation
     * @param {string} key - The storage key
     * @param {Object} defaultValue - Default object value
     * @param {Function} validator - Optional validator function
     * @returns {Object} The object value
     */
    const getObject = (key, defaultValue = {}, validator = null) => {
        const value = safeGet(key, defaultValue);
        if (typeof value !== 'object' || value === null) {
            return defaultValue;
        }
        return validator ? (validator(value) ? value : defaultValue) : value;
    };

    /**
     * Set an object with validation
     * @param {string} key - The storage key
     * @param {Object} value - The object to store
     * @param {Function} validator - Optional validator function
     * @returns {boolean} Success status
     */
    const setObject = (key, value, validator = null) => {
        if (typeof value !== 'object' || value === null) {
            console.warn(`Attempted to set non-object value for key "${key}"`);
            return false;
        }
        if (validator && !validator(value)) {
            console.warn(`Object validation failed for key "${key}"`);
            return false;
        }
        return safeSet(key, value);
    };

    /**
     * Check if localStorage is available
     * @returns {boolean} Whether localStorage is available
     */
    const isAvailable = () => {
        try {
            const test = '__storage_test__';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch {
            return false;
        }
    };

    /**
     * Get all storage keys that match a prefix
     * @param {string} prefix - The prefix to match
     * @returns {string[]} Array of matching keys
     */
    const getKeysWithPrefix = (prefix) => {
        const keys = [];
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(prefix)) {
                    keys.push(key);
                }
            }
        } catch (error) {
            console.warn('Failed to iterate localStorage keys:', error);
        }
        return keys;
    };

    /**
     * Clear all storage keys that match a prefix
     * @param {string} prefix - The prefix to match and clear
     * @returns {number} Number of keys cleared
     */
    const clearWithPrefix = (prefix) => {
        const keys = getKeysWithPrefix(prefix);
        let cleared = 0;
        keys.forEach(key => {
            if (safeRemove(key)) {
                cleared++;
            }
        });
        return cleared;
    };

    /**
     * Migrate old storage keys to new standardized names
     * @returns {Object} Migration results with counts
     */
    const migrateLegacyKeys = () => {
        const results = {
            migrated: 0,
            errors: 0,
            skipped: 0,
            details: []
        };

        try {
            // Check for legacy keys and migrate them
            Object.entries(LEGACY_KEY_MAPPINGS).forEach(([legacyKey, newKey]) => {
                try {
                    const oldValue = localStorage.getItem(legacyKey);
                    if (oldValue !== null) {
                        // Check if new key already exists
                        const newValue = localStorage.getItem(newKey);
                        if (newValue === null) {
                            // Migrate the value
                            safeSet(newKey, oldValue);
                            safeRemove(legacyKey);
                            results.migrated++;
                            results.details.push(`Migrated "${legacyKey}" -> "${newKey}"`);
                        } else {
                            // Skip if new key already exists
                            results.skipped++;
                            results.details.push(`Skipped "${legacyKey}" -> "${newKey}" (new key exists)`);
                        }
                    }
                } catch (error) {
                    results.errors++;
                    results.details.push(`Error migrating "${legacyKey}": ${error.message}`);
                }
            });

            // Log migration results (critical info)
            console.info('Storage migration completed:', results);
            
        } catch (error) {
            console.error('Storage migration failed:', error);
            results.errors++;
        }

        return results;
    };

    /**
     * Get all storage keys for audit purposes
     * @returns {string[]} Array of all storage keys
     */
    const getAllKeys = () => {
        const keys = [];
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key) {
                    keys.push(key);
                }
            }
        } catch (error) {
            console.warn('Failed to iterate localStorage keys:', error);
        }
        return keys;
    };

    /**
     * Audit storage keys for consistency and deprecated usage
     * @returns {Object} Audit results
     */
    const auditKeys = () => {
        const allKeys = getAllKeys();
        const standardKeys = Object.values(STORAGE_KEYS);
        const legacyKeys = Object.keys(LEGACY_KEY_MAPPINGS);
        
        const results = {
            totalKeys: allKeys.length,
            standardKeys: [],
            legacyKeys: [],
            unknownKeys: [],
            statistics: {
                standard: 0,
                legacy: 0,
                unknown: 0
            }
        };

        allKeys.forEach(key => {
            if (standardKeys.includes(key)) {
                results.standardKeys.push(key);
                results.statistics.standard++;
            } else if (legacyKeys.includes(key)) {
                results.legacyKeys.push(key);
                results.statistics.legacy++;
            } else {
                results.unknownKeys.push(key);
                results.statistics.unknown++;
            }
        });

        return results;
    };

    // Public API
    const StorageUtils = {
        // Constants
        KEYS: STORAGE_KEYS,
        DEFAULTS: DEFAULTS,
        LEGACY_MAPPINGS: LEGACY_KEY_MAPPINGS,
        
        // Core methods
        get: safeGet,
        set: safeSet,
        remove: safeRemove,
        
        // Type-specific methods
        getBoolean,
        setBoolean,
        getNumber,
        setNumber,
        getObject,
        setObject,
        
        // Utility methods
        isAvailable,
        getKeysWithPrefix,
        clearWithPrefix,
        migrateLegacyKeys,
        getAllKeys,
        auditKeys
    };

    // Export for both module and global usage
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = StorageUtils;
    } else {
        global.StorageUtils = StorageUtils;
    }

    // Migrate legacy keys as soon as the module loads
    StorageUtils.migrateLegacyKeys();

})(typeof window !== 'undefined' ? window : this);</script>
<script>/**
 * Simple About:Blank and Blob Tab Utility
 * Opens content in new tabs using Blob URLs or about:blank
 */

(function (global) {
    'use strict';

    const AboutBlank = {
        /**
         * Open HTML content in a new Blob tab
         * @param {string} html - The HTML content to display
         */
        openBlob: (html) => {
            try {
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const win = window.open(url, '_blank');

                if (!win) {
                    console.error('Popup blocked');
                    return null;
                }

                // Clean up the blob URL after the page loads to free memory
                win.onload = () => {
                    URL.revokeObjectURL(url);
                };

                return win;
            } catch (e) {
                console.error('Failed to open blob tab:', e);
                return null;
            }
        },

        /**
         * Open HTML content in a new about:blank tab
         * @param {string} html - The HTML content to display
         */
        openAboutBlank: (html) => {
            try {
                const win = window.open('about:blank', '_blank');

                if (!win) {
                    console.error('Popup blocked');
                    return null;
                }

                win.document.write(html);
                win.document.close();

                return win;
            } catch (e) {
                console.error('Failed to open about:blank tab:', e);
                return null;
            }
        },

        /**
         * Open a URL in a new tab
         * @param {string} url - The URL to open
         */
        openURL: (url) => {
            return window.open(url, '_blank');
        }
    };

    // Expose to window
    global.AboutBlank = AboutBlank;

    // Backward compatibility if needed, otherwise you can remove this
    global.BlobTabUtils = AboutBlank;

})(window);
</script>
<script>try {
    let effectsContainer = document.querySelector('.effects-container');
    if (!effectsContainer) {
        effectsContainer = document.createElement('div');
        effectsContainer.className = 'effects-container';
        document.body.appendChild(effectsContainer);
    }
    Object.assign(effectsContainer.style, {
        position: "fixed",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        zIndex: "-1",
        overflow: "hidden"
    });

    let currentTheme = localStorage.getItem('selectedTheme') || 'dark';
    let currentDotSpeed = localStorage.getItem('selectedDotSpeed') || 'normal';
    let currentDensity = localStorage.getItem('effectDensity') || 'high';
    let particles = [];
    let isActive = document.visibilityState === 'visible';

    const speedConfigs = {
        slow: { min: 5, max: 10 },
        normal: { min: 2, max: 7 },
        fast: { min: 1, max: 3 }
    };

    const densityConfigs = {
        low: { dot: 30, sparkle: 10, comet: 2, star: 4000 },
        medium: { dot: 50, sparkle: 20, comet: 5, star: 3400 },
        high: { dot: 100, sparkle: 40, comet: 10, star: 2800 }
    };

    const themes = {
        dark: "linear-gradient(to bottom, #000000, #0a0a0a, #111111, #1a1a1a, #222222)",
        night: "black",
        og: "radial-gradient(ellipse at center, #000000, #0a0a0a, #111111, #1a1a1a, #222222)",
        fortnite: { video: "https://dl.dropboxusercontent.com/s/abc456/fortnite_trailer_2025.mp4", youtube: "https://www.youtube.com/watch?v=kDP0BrvBqt0" }
    };

    function createParticle(type) {
        const particle = document.createElement("div");
        particle.className = type;
        const config = speedConfigs[currentDotSpeed];
        const duration = config.min + Math.random() * (config.max - config.min);
        Object.assign(particle.style, {
            left: `${Math.random() * 100}vw`,
            top: `${Math.random() * 100}vh`,
            animationDuration: `${duration}s`
        });
        return particle;
    }

    function createComet() {
        const comet = document.createElement("div");
        comet.className = "comet";
        const startPos = { x: Math.random() * 100, y: Math.random() * 100 };
        const angle = Math.random() * 360;
        const distance = 20 + Math.random() * 130;
        const endX = startPos.x + Math.cos(angle * Math.PI / 180) * distance;
        const endY = startPos.y + Math.sin(angle * Math.PI / 180) * distance;
        const duration = 5 + Math.random() * 5;
        Object.assign(comet.style, {
            left: `${startPos.x}vw`,
            top: `${startPos.y}vh`,
            animationDuration: `${duration}s`,
            "--start-x": `${startPos.x}vw`,
            "--start-y": `${startPos.y}vh`,
            "--end-x": `${endX}vw`,
            "--end-y": `${endY}vh`,
            zIndex: "100"
        });
        return comet;
    }

    function createShootingStar() {
        const star = document.createElement("div");
        star.className = "shooting-star";
        const startPos = { x: Math.random() * 100, y: Math.random() * 100 };
        const angle = Math.random() * 360;
        const distance = 20 + Math.random() * 130;
        const endX = startPos.x + Math.cos(angle * Math.PI / 180) * distance;
        const endY = startPos.y + Math.sin(angle * Math.PI / 180) * distance;
        const duration = 2.5 + Math.random() * 1;
        Object.assign(star.style, {
            left: `${startPos.x}vw`,
            top: `${startPos.y}vh`,
            animationDuration: `${duration}s`,
            "--start-x": `${startPos.x}vw`,
            "--start-y": `${startPos.y}vh`,
            "--end-x": `${endX}vw`,
            "--end-y": `${endY}vh`,
            zIndex: "100"
        });
        return star;
    }

    function updateEffects() {
        if (!effectsContainer || !isActive) return;

        const performanceMode = localStorage.getItem('performanceMode') === 'true';
        if (performanceMode) {
            particles.forEach(p => p.element.remove());
            particles = [];
            return;
        }

        particles.forEach(p => p.element.remove());
        particles = [];

        const config = densityConfigs[currentDensity];
        const isMobile = window.innerWidth < 768;
        const dotCount = isMobile ? Math.floor(config.dot * 0.6) : config.dot;
        const sparkleCount = isMobile ? Math.floor(config.sparkle * 0.6) : config.sparkle;
        const cometCount = isMobile ? Math.floor(config.comet * 0.6) : config.comet;

        for (let i = 0; i < dotCount; i++) {
            const dot = createParticle("dot");
            effectsContainer.appendChild(dot);
            particles.push({ element: dot, type: "dot" });
        }

        for (let i = 0; i < sparkleCount; i++) {
            const sparkle = createParticle("sparkle");
            effectsContainer.appendChild(sparkle);
            particles.push({ element: sparkle, type: "sparkle" });
        }

        for (let i = 0; i < cometCount; i++) {
            const comet = createComet();
            effectsContainer.appendChild(comet);
            particles.push({ element: comet, type: "comet" });
            comet.addEventListener('animationend', () => comet.remove());
        }
    }

    function extractYouTubeId(url) {
        try {
            const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)/;
            const match = url.match(regex);
            return match ? match[1] : null;
        } catch (e) {
            return null;
        }
    }

    function isValidVideoUrl(url) {
        try {
            return url.match(/\.(mp4|webm|ogg)$/i);
        } catch (e) {
            return false;
        }
    }

 // effects.js (relevant section)
function preloadVideo(url) {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = url;
    link.as = 'video'; // Specify the resource type
    document.head.appendChild(link);
}

function setTheme(theme) {
    // Example: Preload a stylesheet
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = `/themes/${theme}.css`;
    link.as = 'style';
    document.head.appendChild(link);
}

function initEffects() {
    // Initialize effects, including preloading
    preloadVideo('video.mp4');
    setTheme('dark');
}

document.addEventListener('DOMContentLoaded', initEffects);

    function setTheme(theme) {
        try {
            currentTheme = theme;
            localStorage.setItem('selectedTheme', theme);

            let background = document.querySelector('.background');
            if (!background) {
                background = document.createElement('div');
                background.className = 'background';
                background.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2;';
                document.body.appendChild(background);
            }

            const cachedBgStyle = localStorage.getItem('cachedBgStyle');
            if (cachedBgStyle && theme !== 'custom' && themes[theme] === cachedBgStyle) {
                document.documentElement.style.setProperty('--theme-background', cachedBgStyle);
            }

            const existingVideo = background.querySelector('video, iframe');
            if (existingVideo) {
                existingVideo.remove();
            }

            let bgStyle = themes.og;
            document.documentElement.style.setProperty('--theme-background', bgStyle);
            const defaultVideo = 'https://dl.dropboxusercontent.com/s/abc456/fortnite_trailer_2025.mp4';
            preloadVideo(defaultVideo);

            if (theme === 'custom') {
                const customColor = localStorage.getItem('customBgColor') || '#000000';
                const customGradient = localStorage.getItem('customGradient') || '';
                let customVideoUrl = localStorage.getItem('customVideoUrl') || defaultVideo;
                preloadVideo(customVideoUrl);

                const youtubeId = extractYouTubeId(customVideoUrl);
                if (youtubeId) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'background-placeholder';
                    placeholder.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: -1;';
                    background.appendChild(placeholder);

                    const iframe = document.createElement('iframe');
                    iframe.className = 'background-video';
                    iframe.src = `https://www.youtube.com/embed/${youtubeId}?autoplay=1&loop=1&mute=1&controls=0&playlist=${youtubeId}`;
                    iframe.allow = 'autoplay; encrypted-media';
                    iframe.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; opacity: 0; border: none;';
                    iframe.addEventListener('error', () => {
                        alert('YouTube embed failed. Using default Fortnite video.');
                        loadDefaultVideo(defaultVideo, background, customGradient, customColor);
                    });
                    background.appendChild(iframe);
                    setTimeout(() => {
                        iframe.style.opacity = '0.8';
                        placeholder.remove();
                        document.documentElement.style.setProperty('--theme-background', 'transparent');
                        localStorage.setItem('cachedBgStyle', 'transparent');
                    }, 1000);
                } else if (customVideoUrl && isValidVideoUrl(customVideoUrl)) {
                    const video = document.createElement('video');
                    video.className = 'background-video';
                    video.src = customVideoUrl;
                    video.autoplay = true;
                    video.loop = true;
                    video.muted = true;
                    video.playsInline = true;
                    video.addEventListener('error', () => {
                        alert('Invalid video URL. Please use a direct MP4 link (e.g., https://example.com/video.mp4).');
                        loadDefaultVideo(defaultVideo, background, customGradient, customColor);
                    });
                    video.addEventListener('loadeddata', () => {
                        background.appendChild(video);
                        document.documentElement.style.setProperty('--theme-background', 'transparent');
                        localStorage.setItem('cachedBgStyle', 'transparent');
                    });
                    background.appendChild(video);
                } else {
                    if (customVideoUrl) {
                        alert('Invalid video URL. Please use a direct MP4 link (e.g., https://example.com/video.mp4).');
                    }
                    loadDefaultVideo(defaultVideo, background, customGradient, customColor);
                }
            } else if (themes[theme]?.youtube) {
                const youtubeId = extractYouTubeId(themes[theme].youtube);
                if (youtubeId) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'background-placeholder';
                    placeholder.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: -1;';
                    background.appendChild(placeholder);

                    const iframe = document.createElement('iframe');
                    iframe.className = 'background-video';
                    iframe.src = `https://www.youtube.com/embed/${youtubeId}?autoplay=1&loop=1&mute=1&controls=0&playlist=${youtubeId}`;
                    iframe.allow = 'autoplay; encrypted-media';
                    iframe.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; opacity: 0; border: none;';
                    iframe.addEventListener('error', () => {
                        alert('YouTube embed failed. Using default Fortnite video.');
                        loadDefaultVideo(themes[theme].video, background, themes.og, '#000000');
                    });
                    background.appendChild(iframe);
                    setTimeout(() => {
                        iframe.style.opacity = '0.8';
                        placeholder.remove();
                        document.documentElement.style.setProperty('--theme-background', 'transparent');
                        localStorage.setItem('cachedBgStyle', 'transparent');
                    }, 1000);
                } else {
                    loadDefaultVideo(themes[theme].video, background, themes.og, '#000000');
                }
            } else if (themes[theme]?.video) {
                const video = document.createElement('video');
                video.className = 'background-video';
                video.src = themes[theme].video;
                video.autoplay = true;
                video.loop = true;
                video.muted = true;
                video.playsInline = true;
                video.addEventListener('error', () => {
                    bgStyle = themes.og;
                    document.documentElement.style.setProperty('--theme-background', bgStyle);
                    localStorage.setItem('cachedBgStyle', bgStyle);
                });
                video.addEventListener('loadeddata', () => {
                    background.appendChild(video);
                    document.documentElement.style.setProperty('--theme-background', 'transparent');
                    localStorage.setItem('cachedBgStyle', 'transparent');
                });
                background.appendChild(video);
            } else {
                bgStyle = themes[theme] || themes.og;
                document.documentElement.style.setProperty('--theme-background', bgStyle);
                localStorage.setItem('cachedBgStyle', bgStyle);
            }

            updateEffects();
        } catch (e) {
            document.documentElement.style.setProperty('--theme-background', themes.og);
            localStorage.setItem('cachedBgStyle', themes.og);
        }
    }

    function loadDefaultVideo(url, background, gradient, color) {
        try {
            if (extractYouTubeId(url)) {
                const bgStyle = gradient || color;
                document.documentElement.style.setProperty('--theme-background', bgStyle);
                localStorage.setItem('cachedBgStyle', bgStyle);
                return;
            }
            const video = document.createElement('video');
            video.className = 'background-video';
            video.src = url;
            video.autoplay = true;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.addEventListener('error', () => {
                const bgStyle = gradient || color;
                document.documentElement.style.setProperty('--theme-background', bgStyle);
                localStorage.setItem('cachedBgStyle', bgStyle);
            });
            video.addEventListener('loadeddata', () => {
                background.appendChild(video);
                document.documentElement.style.setProperty('--theme-background', 'transparent');
                localStorage.setItem('cachedBgStyle', 'transparent');
            });
            background.appendChild(video);
        } catch (e) {
            const bgStyle = gradient || color;
            document.documentElement.style.setProperty('--theme-background', bgStyle);
            localStorage.setItem('cachedBgStyle', bgStyle);
        }
    }

    function setDotSpeed(speed) {
        try {
            if (!Object.keys(speedConfigs).includes(speed)) return;
            currentDotSpeed = speed;
            localStorage.setItem('selectedDotSpeed', speed);
            updateEffects();
        } catch (e) {}
    }

    function setEffectDensity(density) {
        try {
            if (!Object.keys(densityConfigs).includes(density)) return;
            currentDensity = density;
            localStorage.setItem('effectDensity', density);
            updateEffects();
        } catch (e) {}
    }

    function initEffects() {
        try {
            if (effectsContainer) {
                const cachedBgStyle = localStorage.getItem('cachedBgStyle');
                if (cachedBgStyle) {
                    document.documentElement.style.setProperty('--theme-background', cachedBgStyle);
                }

                setTheme(currentTheme);
                setDotSpeed(currentDotSpeed);
                setEffectDensity(currentDensity);
                window.addEventListener('resize', debounce(updateEffects, 250));

                let spawnTimeout;
                function spawnStarWithRandomInterval() {
                    if (!isActive || localStorage.getItem('performanceMode') === 'true') return;
                    const star = createShootingStar();
                    effectsContainer.appendChild(star);
                    star.addEventListener('animationend', () => star.remove());
                    const nextSpawn = densityConfigs[currentDensity].star + Math.random() * 3000;
                    spawnTimeout = setTimeout(spawnStarWithRandomInterval, nextSpawn);
                }

                if (isActive && localStorage.getItem('performanceMode') !== 'true') {
                    spawnStarWithRandomInterval();
                }

                document.addEventListener('visibilitychange', () => {
                    isActive = document.visibilityState === 'visible';
                    if (isActive && localStorage.getItem('performanceMode') !== 'true') {
                        updateEffects();
                        spawnStarWithRandomInterval();
                    } else {
                        clearTimeout(spawnTimeout);
                        particles.forEach(p => p.element.remove());
                        particles = [];
                    }
                });

                window.addEventListener('beforeunload', () => {
                    isActive = false;
                    clearTimeout(spawnTimeout);
                });
            }
        } catch (e) {}
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    initEffects();

    window.setTheme = setTheme;
    window.setDotSpeed = setDotSpeed;
    window.setEffectDensity = setEffectDensity;
    window.updateEffects = updateEffects;
} catch (e) {
    alert('An error occurred in the effects script. Visual effects may not work.');
}</script>
<script>document.addEventListener('DOMContentLoaded', function() {
    function getCurrentScriptPath() {
        const script = document.currentScript || document.querySelector('script[src*="pluginstuff.js"]');
        if (script?.src) {
            return script.src;
        }
        return null;
    }

    function loadResources() {
        const scriptPath = getCurrentScriptPath();
        if (!scriptPath) return;
        const baseDir = scriptPath.substring(0, scriptPath.lastIndexOf('/'));
        const isActivePage = window.location.pathname.startsWith('/active');
        const resources = [
            { element: 'link', props: { rel: 'stylesheet', type: 'text/css', href: `${baseDir}/style.css` } },
            ...(isActivePage ? [] : [{ element: 'script', props: { type: 'text/javascript', src: `${baseDir}/effects.js` } }])
        ];
        resources.forEach(({ element, props }) => {
            const el = document.createElement(element);
            Object.assign(el, props);
            document.head.appendChild(el);
        });
    }

    function inFrame() {
        try {
            return window.self !== window.top;
        } catch {
            return true;
        }
    }

    function applyAntiClose() {
        const targetWindow = inFrame() ? window.top : window;
        const handler = function(e) {
            e.preventDefault();
            e.returnValue = 'Are you sure you want to leave?';
            return 'Are you sure you want to leave?';
        };
        const antiCloseEnabled = localStorage.getItem('antiClose') === 'true';

        try {
            targetWindow.removeEventListener('beforeunload', handler);
            if (antiCloseEnabled) {
                targetWindow.addEventListener('beforeunload', handler);
            }
        } catch {}
    }

    function initializeAntiClose() {
        applyAntiClose();
        window.addEventListener('storage', (e) => {
            if (e.key === 'antiClose') applyAntiClose();
        });
        window.addEventListener('pageshow', applyAntiClose);
        window.addEventListener('load', applyAntiClose);
    }

    function initializePanicKey() {
        let panicKey = localStorage.getItem('panicKey') || 'Escape';
        let panicAction = localStorage.getItem('panicAction') || 'https://edpuzzle.com/notifications';
        const panicKeyInput = document.getElementById('panic-key');
        const panicKeyLabel = document.querySelector('label[for="panic-key"] small');
        const settingsOverlay = document.querySelector('.settings-overlay--scoped');

        if (!panicKeyInput || !panicKeyLabel) return;

        function updatePanicKeyDisplay() {
            const displayKey = panicKey.replace('Key', '').replace('Digit', '');
            panicKeyInput.value = displayKey;
            panicKeyInput.title = `Current panic key: ${displayKey}`;
            panicKeyLabel.textContent = `Current: ${displayKey}`;
        }

        function triggerPanicAction() {
            try {
                window.location.replace(panicAction);
                setTimeout(() => {
                    if (window.location.href !== panicAction) {
                        window.location.href = panicAction;
                    }
                }, 100);
            } catch {
                window.location.href = panicAction;
            }
        }

        updatePanicKeyDisplay();
        panicKeyInput.readOnly = false;
        panicKeyInput.style.cursor = 'text';
        panicKeyInput.title = 'Type a single key or press a key to set';

        panicKeyInput.addEventListener('keydown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const newKey = e.key === ' ' ? 'Space' : e.key;
            if (['Control', 'Alt', 'Shift', 'Meta'].includes(newKey)) {
                alert('Please use a non-modifier key.');
                return;
            }
            panicKey = newKey;
            localStorage.setItem('panicKey', panicKey);
            updatePanicKeyDisplay();
            this.classList.remove('active');
            if (settingsOverlay) {
                settingsOverlay.classList.remove('panic-key-active');
            }
        });

        panicKeyInput.addEventListener('focus', function() {
            this.classList.add('active');
            if (settingsOverlay) {
                settingsOverlay.classList.add('panic-key-active');
            }
        });

        panicKeyInput.addEventListener('blur', function() {
            this.classList.remove('active');
            if (settingsOverlay) {
                settingsOverlay.classList.remove('panic-key-active');
            }
            updatePanicKeyDisplay();
        });

        panicKeyInput.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            panicKey = 'Escape';
            localStorage.setItem('panicKey', panicKey);
            updatePanicKeyDisplay();
        });

        document.addEventListener('keydown', function(e) {
            const keyPressed = e.key === ' ' ? 'Space' : e.key;
            if (keyPressed === panicKey) {
                const activeElement = document.activeElement;
                const isTyping = activeElement.tagName === 'INPUT' || 
                               activeElement.tagName === 'TEXTAREA' || 
                               activeElement.isContentEditable ||
                               (activeElement.tagName === 'DIV' && activeElement.getAttribute('role') === 'searchbox');
                if (isTyping) return;
                e.preventDefault();
                e.stopPropagation();
                triggerPanicAction();
            }
        }, { capture: true, passive: false });

        window.addEventListener('storage', function(e) {
            if (e.key === 'panicKey') {
                panicKey = e.newValue || 'Escape';
                updatePanicKeyDisplay();
            }
            if (e.key === 'panicAction') {
                panicAction = e.newValue || 'https://edpuzzle.com/notifications';
            }
        });
    }

    const cloaks = [
        { name: "default", icon: "https://en.wikipedia.org/favicon.ico", title: "World War II - Wikipedia" },
        { name: "Google", icon: "https://www.google.com/chrome/static/images/chrome-logo-m100.svg", title: "New Tab" },
        { name: "Classroom", icon: "https://ssl.gstatic.com/classroom/favicon.png", title: "Home" },
        { name: "Canva", icon: "https://static.canva.com/static/images/android-192x192-2.png", title: "Home - Canva" },
        { name: "Quiz", icon: "https://ssl.gstatic.com/docs/spreadsheets/forms/forms_icon_2023q4.ico", title: "You've already responded" },
        { name: "powerschool", icon: "https://waverlyk12.powerschool.com/favicon.ico", title: "Grades and Attendance" },
        { name: "Edpuzzle", icon: "https://edpuzzle.imgix.net/favicons/favicon-32.png", title: "Edpuzzle" },
    ];

    function applyCloak(cloakName) {
        const cloak = cloaks.find(c => c.name === cloakName) || cloaks[0];
        document.title = cloak.title;

        let existingFavicon = document.querySelector("link[rel*='icon']");
        if (existingFavicon) existingFavicon.remove();

        if (cloak.icon) {
            const link = document.createElement('link');
            link.rel = 'icon';
            const ext = cloak.icon.split('.').pop().toLowerCase();
            link.type = ext === 'png' ? 'image/png' : ext === 'svg' ? 'image/svg+xml' : 'image/x-icon';
            link.href = cloak.icon + (cloak.icon.includes('?') ? '&' : '?') + 'v=' + Date.now();
            document.head.appendChild(link);
            localStorage.setItem('cloak', JSON.stringify({ title: cloak.title, icon: cloak.icon }));
        }
    }

    const container = document.createElement('div');
    container.className = 'effects-container';
    document.body.appendChild(container);

    window.openURLInAboutBlank = function(url) {
        const win = window.open('about:blank', '_blank');
        if (win) {
            win.location.href = url;
        }
    };

    loadResources();
    initializeAntiClose();
    initializePanicKey();

    const savedCloak = localStorage.getItem('selectedCloak') || 'default';
    applyCloak(savedCloak);

    window.addEventListener('storage', (e) => {
        if (e.key === 'selectedCloak') applyCloak(e.newValue || 'default');
    });

    window.addEventListener('load', () => applyCloak(localStorage.getItem('selectedCloak') || 'default'));
    window.addEventListener('pageshow', () => applyCloak(localStorage.getItem('selectedCloak') || 'default'));

    const cloakSelect = document.querySelector('[data-cloak-select]');
    if (cloakSelect) {
        cloakSelect.addEventListener('change', () => {
            const selectedCloak = cloakSelect.value;
            localStorage.setItem('selectedCloak', selectedCloak);
            applyCloak(selectedCloak);
        });
        cloakSelect.value = savedCloak;
    }
});</script>
<script>!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):t.ColorThief=r()}(this,function(){if(!t)var t={map:function(t,r){var n={};return r?t.map(function(t,o){return n.index=o,r.call(n,t)}):t.slice()},naturalOrder:function(t,r){return t<r?-1:t>r?1:0},sum:function(t,r){var n={};return t.reduce(r?function(t,o,e){return n.index=e,t+r.call(n,o)}:function(t,r){return t+r},0)},max:function(r,n){return Math.max.apply(null,n?t.map(r,n):r)}};var r=function(){var r=5,n=8-r,o=1e3;function e(t,n,o){return(t<<2*r)+(n<<r)+o}function i(t){var r=[],n=!1;function o(){r.sort(t),n=!0}return{push:function(t){r.push(t),n=!1},peek:function(t){return n||o(),void 0===t&&(t=r.length-1),r[t]},pop:function(){return n||o(),r.pop()},size:function(){return r.length},map:function(t){return r.map(t)},debug:function(){return n||o(),r}}}function u(t,r,n,o,e,i,u){this.r1=t,this.r2=r,this.g1=n,this.g2=o,this.b1=e,this.b2=i,this.histo=u}function a(){this.vboxes=new i(function(r,n){return t.naturalOrder(r.vbox.count()*r.vbox.volume(),n.vbox.count()*n.vbox.volume())})}function s(r,n){if(n.count()){var o=n.r2-n.r1+1,i=n.g2-n.g1+1,u=t.max([o,i,n.b2-n.b1+1]);if(1==n.count())return[n.copy()];var a,s,h,c,f=0,v=[],l=[];if(u==o)for(a=n.r1;a<=n.r2;a++){for(c=0,s=n.g1;s<=n.g2;s++)for(h=n.b1;h<=n.b2;h++)c+=r[e(a,s,h)]||0;v[a]=f+=c}else if(u==i)for(a=n.g1;a<=n.g2;a++){for(c=0,s=n.r1;s<=n.r2;s++)for(h=n.b1;h<=n.b2;h++)c+=r[e(s,a,h)]||0;v[a]=f+=c}else for(a=n.b1;a<=n.b2;a++){for(c=0,s=n.r1;s<=n.r2;s++)for(h=n.g1;h<=n.g2;h++)c+=r[e(s,h,a)]||0;v[a]=f+=c}return v.forEach(function(t,r){l[r]=f-t}),function(t){var r,o,e,i,u,s=t+"1",h=t+"2",c=0;for(a=n[s];a<=n[h];a++)if(v[a]>f/2){for(e=n.copy(),i=n.copy(),u=(r=a-n[s])<=(o=n[h]-a)?Math.min(n[h]-1,~~(a+o/2)):Math.max(n[s],~~(a-1-r/2));!v[u];)u++;for(c=l[u];!c&&v[u-1];)c=l[--u];return e[h]=u,i[s]=e[h]+1,[e,i]}}(u==o?"r":u==i?"g":"b")}}return u.prototype={volume:function(t){return this._volume&&!t||(this._volume=(this.r2-this.r1+1)*(this.g2-this.g1+1)*(this.b2-this.b1+1)),this._volume},count:function(t){var r=this.histo;if(!this._count_set||t){var n,o,i,u=0;for(n=this.r1;n<=this.r2;n++)for(o=this.g1;o<=this.g2;o++)for(i=this.b1;i<=this.b2;i++)u+=r[e(n,o,i)]||0;this._count=u,this._count_set=!0}return this._count},copy:function(){return new u(this.r1,this.r2,this.g1,this.g2,this.b1,this.b2,this.histo)},avg:function(t){var n=this.histo;if(!this._avg||t){var o,i,u,a,s=0,h=1<<8-r,c=0,f=0,v=0;for(i=this.r1;i<=this.r2;i++)for(u=this.g1;u<=this.g2;u++)for(a=this.b1;a<=this.b2;a++)s+=o=n[e(i,u,a)]||0,c+=o*(i+.5)*h,f+=o*(u+.5)*h,v+=o*(a+.5)*h;this._avg=s?[~~(c/s),~~(f/s),~~(v/s)]:[~~(h*(this.r1+this.r2+1)/2),~~(h*(this.g1+this.g2+1)/2),~~(h*(this.b1+this.b2+1)/2)]}return this._avg},contains:function(t){var r=t[0]>>n;return gval=t[1]>>n,bval=t[2]>>n,r>=this.r1&&r<=this.r2&&gval>=this.g1&&gval<=this.g2&&bval>=this.b1&&bval<=this.b2}},a.prototype={push:function(t){this.vboxes.push({vbox:t,color:t.avg()})},palette:function(){return this.vboxes.map(function(t){return t.color})},size:function(){return this.vboxes.size()},map:function(t){for(var r=this.vboxes,n=0;n<r.size();n++)if(r.peek(n).vbox.contains(t))return r.peek(n).color;return this.nearest(t)},nearest:function(t){for(var r,n,o,e=this.vboxes,i=0;i<e.size();i++)((n=Math.sqrt(Math.pow(t[0]-e.peek(i).color[0],2)+Math.pow(t[1]-e.peek(i).color[1],2)+Math.pow(t[2]-e.peek(i).color[2],2)))<r||void 0===r)&&(r=n,o=e.peek(i).color);return o},forcebw:function(){var r=this.vboxes;r.sort(function(r,n){return t.naturalOrder(t.sum(r.color),t.sum(n.color))});var n=r[0].color;n[0]<5&&n[1]<5&&n[2]<5&&(r[0].color=[0,0,0]);var o=r.length-1,e=r[o].color;e[0]>251&&e[1]>251&&e[2]>251&&(r[o].color=[255,255,255])}},{quantize:function(h,c){if(!h.length||c<2||c>256)return!1;var f=function(t){var o,i=new Array(1<<3*r);return t.forEach(function(t){o=e(t[0]>>n,t[1]>>n,t[2]>>n),i[o]=(i[o]||0)+1}),i}(h);f.forEach(function(){});var v=function(t,r){var o,e,i,a=1e6,s=0,h=1e6,c=0,f=1e6,v=0;return t.forEach(function(t){(o=t[0]>>n)<a?a=o:o>s&&(s=o),(e=t[1]>>n)<h?h=e:e>c&&(c=e),(i=t[2]>>n)<f?f=i:i>v&&(v=i)}),new u(a,s,h,c,f,v,r)}(h,f),l=new i(function(r,n){return t.naturalOrder(r.count(),n.count())});function g(t,r){for(var n,e=t.size(),i=0;i<o;){if(e>=r)return;if(i++>o)return;if((n=t.pop()).count()){var u=s(f,n),a=u[0],h=u[1];if(!a)return;t.push(a),h&&(t.push(h),e++)}else t.push(n),i++}}l.push(v),g(l,.75*c);for(var p=new i(function(r,n){return t.naturalOrder(r.count()*r.volume(),n.count()*n.volume())});l.size();)p.push(l.pop());g(p,c);for(var d=new a;p.size();)d.push(p.pop());return d}}}().quantize,n=function(t){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.width=this.canvas.width=t.width,this.height=this.canvas.height=t.height,this.context.drawImage(t,0,0,this.width,this.height)};n.prototype.getImageData=function(){return this.context.getImageData(0,0,this.width,this.height)};var o=function(){};return o.prototype.getColor=function(t,r){return void 0===r&&(r=10),this.getPalette(t,5,r)[0]},o.prototype.getPalette=function(t,o,e){var i=function(t){var r=t.colorCount,n=t.quality;if(void 0!==r&&Number.isInteger(r)){if(1===r)throw new Error("colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()");r=Math.max(r,2),r=Math.min(r,20)}else r=10;return void 0===n||Number.isInteger(n)?n=10:n<1&&(n=10),{colorCount:r,quality:n}}({colorCount:o,quality:e}),u=new n(t),a=function(t,r,n){for(var o=t,e=[],i=0,u=void 0,a=void 0,s=void 0,h=void 0,c=void 0;i<r;i+=n)a=o[0+(u=4*i)],s=o[u+1],h=o[u+2],(void 0===(c=o[u+3])||c>=125)&&(a>250&&s>250&&h>250||e.push([a,s,h]));return e}(u.getImageData().data,u.width*u.height,i.quality),s=r(a,i.colorCount);return s?s.palette():null},o.prototype.getColorFromUrl=function(t,r,n){var o=document.createElement("img"),e=this;o.addEventListener("load",function(){var i=e.getPalette(o,5,n);r(i[0],t)}),o.src=t},o.prototype.getImageData=function(t,r){var n=new XMLHttpRequest;n.open("GET",t,!0),n.responseType="arraybuffer",n.onload=function(){if(200==this.status){var t=new Uint8Array(this.response);o=t.length;for(var n=new Array(o),o=0;o<t.length;o++)n[o]=String.fromCharCode(t[o]);var e=n.join(""),i=window.btoa(e);r("data:image/png;base64,"+i)}},n.send()},o.prototype.getColorAsync=function(t,r,n){var o=this;this.getImageData(t,function(t){var e=document.createElement("img");e.addEventListener("load",function(){var t=o.getPalette(e,5,n);r(t[0],this)}),e.src=t})},o});
</script>
<script>/**
 * Settings Modal Component - Comprehensive settings system
 * Modal-based UI with tab navigation for all application settings
 * Includes migration support for legacy storage keys
 */

class SettingsModal {
    constructor() {
        this.isOpen = false;
        this.currentTab = 'general';
        this.settings = this.loadSettings();
        this.elements = {}; // Initialize elements object
        this.themeApplicationDebounce = null; // Initialize debounce timer

        // Array-based tab configuration for easy reordering
        this.tabs = [
            {
                id: 'general',
                name: 'General',
                icon: '<circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>'
            },
            {
                id: 'movies',
                name: 'Movies',
                icon: '<path d="M18 8a2 2 0 0 0 0-4 2 2 0 0 0-4 0 2 2 0 0 0-4 0 2 2 0 0 0-4 0 2 2 0 0 0 0 4"/><path d="M10 22 9 8"/><path d="m14 22 1-14"/><path d="M20 8c.5 0 .9.4.8 1l-2.6 12c-.1.5-.7 1-1.2 1H7c-.6 0-1.1-.4-1.2-1L3.2 9c-.1-.6.3-1 .8-1Z"/>'
            },
            {
                id: 'appearance',
                name: 'Appearance',
                icon: '<path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.649-1.625c1.812 0 3.461-1.55 3.461-3.478a3.44 3.44 0 0 0-1.032-2.5c-.467-.467-1.022-.658-1.741-.658h-.061a3.44 3.44 0 0 0-1.645.672c-.283.207-.572.375-.879.484a11.5 11.5 0 0 1-1.173.484c-.89.29-1.747.41-2.593.41-2.187 0-3.593-1.02-3.593-2.5 0-1.766 1.261-3 3.02-3 1.652 0 2.813.902 2.813 2.187 0 .646-.195 1.086-.57 1.375-.375.289-.672.375-.883.375-.273 0-.52-.074-.742-.203-.23-.133-.437-.375-.625-.719-.195-.352-.289-.852-.289-1.523 0-.312.039-.66.117-1.023.078-.367.227-.734.437-1.078.21-.344.527-.703.938-1.078.41-.375 1.024-.79 1.836-.79.812 0 1.523.219 2.14.656.617.438 1.336 1.195 2.156 2.273a9.1 9.1 0 0 0 1.562 1.757c.945.86 2.156 1.516 3.633 1.969 1.477.454 3.14.68 4.992.68"/>'
            },
            {
                id: 'offline',
                name: 'Offline',
                icon: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17,8 12,3 7,8"/><line x1="12" y1="3" x2="12" y2="15"/>'
            },
            {
                id: 'privacy',
                name: 'Privacy',
                icon: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><circle cx="12" cy="16" r="1"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>'
            },
            {
                id: 'ai',
                name: 'AI',
                icon: '<path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/>'
            }
        ];

        // Define themes array inside the class
        this.themes = [
            { name: "Dark", primaryColor: "#a1a1a6", secondaryColor: "#ffffff", bgColor: "#0d0d0d", cardColor: "#1a1a1a", textColor: "#eaeaea" },
            { name: "Ocean", primaryColor: "#00b4d8", secondaryColor: "#0077be", bgColor: "#001122", cardColor: "#002244", textColor: "#e0f7fa" },
            { name: "Forest", primaryColor: "#2d5016", secondaryColor: "#4caf50", bgColor: "#0a1a0a", cardColor: "#1a2a1a", textColor: "#e8f5e8" }
        ];

        // Define backgrounds array inside the class
        this.backgrounds = [
            { name: "None", type: "color", value: "#0d0d0d" },
            { name: "Gradient", type: "color", value: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)" },
            { name: "YouTube Video", type: "youtube", value: "" },
            { name: "Image URL", type: "image", value: "" }
        ];

        // Define cloaks array inside the class
        this.cloaks = [
            { name: "Default", icon: "https://edpuzzle.imgix.net/favicons/favicon-32.png", title: "Edpuzzle" },
            { name: "Wikipedia", icon: "https://en.wikipedia.org/favicon.ico", title: "World War II - Wikipedia" },
            { name: "Google", icon: "https://www.google.com/chrome/static/images/chrome-logo-m100.svg", title: "New Tab" },
            { name: "Classroom", icon: "https://ssl.gstatic.com/classroom/favicon.png", title: "Home" },
            { name: "Canva", icon: "https://static.canva.com/static/images/android-192x192-2.png", title: "Home - Canva" },
            { name: "Quiz", icon: "https://ssl.gstatic.com/docs/spreadsheets/forms/forms_icon_2023q4.ico", title: "You've already responded" },
            { name: "Powerschool", icon: "https://waverlyk12.powerschool.com/favicon.ico", title: "Grades and Attendance" },
        ];

        try {
            // Run migration on initialization
            this.migrateOldKeys();

            this.init();
        } catch (error) {
            console.error('SettingsModal initialization error:', error);
            // Don't let initialization errors prevent global exposure
        }
    }

    /**
     * Migrate old storage keys to new standardized names
     * @returns {Object} Migration results
     */
    migrateOldKeys() {
        if (window.StorageUtils) {
            const results = window.StorageUtils.migrateLegacyKeys();
            // Only log migration summary when something actually changed
            if (results.migrated > 0 || results.errors > 0 || results.skipped > 0) {
                console.info('Storage migration summary', {
                    migrated: results.migrated,
                    skipped: results.skipped,
                    errors: results.errors
                });
            }
            return results;
        } else {
            // Fallback migration if StorageUtils is not available
            console.warn('StorageUtils not available, running fallback migration');
            return this.fallbackMigration();
        }
    }

    /**
     * Fallback migration function for when StorageUtils is not available
     * @returns {Object} Migration results
     */
    fallbackMigration() {
        const results = {
            migrated: 0,
            errors: 0,
            skipped: 0,
            details: []
        };

        const legacyMappings = {
            'anti-close': 'antiClose',
            'anti_close': 'antiClose',
            'panic-key': 'panicKey',
            'panic_key': 'panicKey',
            'panic-action': 'panicAction',
            'panic_action': 'panicAction',
            'selected-cloak': 'selectedCloak',
            'selected_cloak': 'selectedCloak',
            'auto-about-blank': 'autoAboutBlank',
            'auto_about_blank': 'autoAboutBlank',
            'auto-blob-tab': 'autoBlobTab',
            'auto_blob_tab': 'autoBlobTab',
            'selected-theme': 'selectedTheme',
            'selected_theme': 'selectedTheme',
            'performance-mode': 'performanceMode',
            'performance_mode': 'performanceMode',
            'custom-favicons': 'customFavicons',
            'custom_favicons': 'customFavicons',
            'favicon-rotation': 'faviconRotation',
            'favicon_rotation': 'faviconRotation',
            'favicon-rotation-interval': 'faviconRotationInterval',
            'favicon_rotation_interval': 'faviconRotationInterval',
            'favicon-visibility-toggle': 'faviconVisibilityToggle',
            'favicon_visibility_toggle': 'faviconVisibilityToggle',
            'prox-server': 'proxServer',
            'prox_server': 'proxServer',
            'proxy-server': 'proxServer',
            'proxy_server': 'proxServer',
            'openai-api-key': 'openAiApiKey',
            'openai_api_key': 'openAiApiKey',
            'gemini-api-key': 'geminiApiKey',
            'gemini_api_key': 'geminiApiKey',
            'search-engine': 'searchEngine',
            'search_engine': 'searchEngine'
        };

        Object.entries(legacyMappings).forEach(([legacyKey, newKey]) => {
            try {
                const oldValue = localStorage.getItem(legacyKey);
                if (oldValue !== null) {
                    const newValue = localStorage.getItem(newKey);
                    if (newValue === null) {
                        localStorage.setItem(newKey, oldValue);
                        localStorage.removeItem(legacyKey);
                        results.migrated++;
                        results.details.push(`Migrated "${legacyKey}" -> "${newKey}"`);
                    } else {
                        results.skipped++;
                        results.details.push(`Skipped "${legacyKey}" -> "${newKey}" (new key exists)`);
                    }
                }
            } catch (error) {
                results.errors++;
                results.details.push(`Error migrating "${legacyKey}": ${error.message}`);
            }
        });

        // Silent in production; callers can inspect returned summary if needed
        return results;
    }

    init() {
        this.createModal();
        this.cacheElements();
        this.bindEvents();
        this.loadInitialState();

        // Initialize offline mode UI
        initOfflineModeUI();
    }

    /**
     * Generate navigation HTML from tabs array
     */
    generateNavigationHTML() {
        return this.tabs.map((tab, index) => {
            const isActive = index === 0; // First tab is active by default
            return `
                <a href="#" data-tab="${tab.id}" class="settings-nav-item ${isActive ? 'active' : ''}" role="tab" aria-selected="${isActive}" tabindex="${isActive ? '0' : '-1'}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        ${tab.icon}
                    </svg>
                    <span>${tab.name}</span>
                </a>
            `;
        }).join('');
    }

    /**
     * Generate tab content HTML from tabs array
     */
    generateTabContentHTML() {
        return this.tabs.map((tab, index) => {
            const isActive = index === 0;
            return this.getTabHTML(tab.id, isActive);
        }).join('');
    }

    /**
     * Get HTML for specific tab
     */
    getTabHTML(tabId, isActive) {
        switch(tabId) {
            case 'general':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="general" role="tabpanel" aria-labelledby="settings-tab-general">
                        <div class="tab-header">
                            <h3 id="settings-tab-general">General</h3>
                            <p>Choose which games library Unblockee should use by default.</p>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label" for="library-select">Game Library</label>
                            <select id="library-select" class="settings-input">
                                <option value="default">Library 1 (from gnmath)</option>
                                <option value="alt">Library 2 (from ultimate game stash)</option>
                            </select>
                            <span class="form-help">Choose which games library to use. Changes apply immediately.</span>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label">
                                <label class="switch-container">
                                    <input type="checkbox" id="widgetbot-enabled-toggle" class="setting-checkbox">
                                    <span class="switch-slider"></span>
                                </label>
                                Enable WidgetBot
                            </label>
                            <span class="form-help">
                                Enable Widgetbot for sitewide discord integration with the Unblockee server.
                            </span>
                        </div>
                    </div>
                `;
            case 'movies':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="movies" role="tabpanel" aria-labelledby="settings-tab-movies">
                        <div class="tab-header">
                            <h3 id="settings-tab-movies">Movies Settings</h3>
                            <p>Control movie ratings and content filtering for the movies section.</p>
                        </div>

                        <div class="settings-group critical">
                            <label class="settings-label" for="max-rating-select">Maximum Rating to Show</label>
                            <select id="max-rating-select" class="settings-input">
                                <option value="PG">PG</option>
                                <option value="PG-13">PG-13</option>
                                <option value="R" selected>R (Default)</option>
                            </select>
                            <span class="form-help">
                                Only movies with ratings at or below this level will be displayed.
                            </span>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label">
                                <label class="switch-container">
                                    <input type="checkbox" id="movies-proxy-enabled-toggle" class="setting-checkbox">
                                    <span class="switch-slider"></span>
                                </label>
                                Enable Proxy for Movies
                            </label>
                            <span class="form-help">
                                Enable proxy functionality when accessing movie content through embed.html. NC and NR rated movies are always hidden.
                            </span>
                        </div>
                    </div>
                `;
            case 'appearance':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="appearance" role="tabpanel" aria-labelledby="settings-tab-appearance">
                        <div class="tab-header">
                            <h3 id="settings-tab-appearance">Appearance</h3>
                            <p>Theme presets and custom colors. Changes apply instantly to the UI.</p>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label" for="theme-preset-select">Theme Preset</label>
                            <select id="theme-preset-select" class="settings-input">
                                <option value="dark">Dark</option>
                                <option value="ocean">Ocean</option>
                                <option value="forest">Forest</option>
                                <option value="custom">Custom (use colors below)</option>
                            </select>
                            <span class="form-help">Pick a base theme or choose Custom and tune the colors below.</span>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label">
                                <label class="switch-container">
                                    <input type="checkbox" id="global-color-thief-toggle" class="setting-checkbox">
                                    <span class="switch-slider"></span>
                                </label>
                                Enable Global Color Thief
                            </label>
                            <span class="form-help">
                                Automatically extract dominant colors from album art, posters, and other images to create dynamic themes.
                            </span>
                        </div>

                        <div class="settings-group info">
                            <div class="tab-subheader">
                                <h4>Custom Theme</h4>
                                <p>Tweak core colors. Values must be valid hex codes (e.g. #0d0d0d or #fff).</p>
                            </div>

                            <div class="custom-theme-grid">
                                <div class="custom-theme-field">
                                    <label class="settings-label" for="theme-primary-color">Primary Color</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="theme-primary-color" class="color-picker">
                                        <input type="text" id="theme-primary-color-text" class="settings-input theme-color-input" placeholder="#a1a1a6" maxlength="7">
                                    </div>
                                    <span class="form-help">Used for highlights and primary accents.</span>
                                </div>

                                <div class="custom-theme-field">
                                    <label class="settings-label" for="theme-secondary-color">Secondary Color</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="theme-secondary-color" class="color-picker">
                                        <input type="text" id="theme-secondary-color-text" class="settings-input theme-color-input" placeholder="#ffffff" maxlength="7">
                                    </div>
                                    <span class="form-help">Used for subtle accents and borders.</span>
                                </div>

                                <div class="custom-theme-field">
                                    <label class="settings-label" for="theme-bg-color">Background Color</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="theme-bg-color" class="color-picker">
                                        <input type="text" id="theme-bg-color-text" class="settings-input theme-color-input" placeholder="#0d0d0d" maxlength="7">
                                    </div>
                                    <span class="form-help">Base background behind the hex pattern.</span>
                                </div>

                                <div class="custom-theme-field">
                                    <label class="settings-label" for="theme-text-color">Text Color</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="theme-text-color" class="color-picker">
                                        <input type="text" id="theme-text-color-text" class="settings-input theme-color-input" placeholder="#ffffff" maxlength="7">
                                    </div>
                                    <span class="form-help">Primary text color for content.</span>
                                </div>
                            </div>

                            <div class="theme-preview-banner" id="theme-preview">
                                <div class="theme-preview-label">Preview swatches</div>
                                <div class="theme-preview-chip primary"></div>
                                <div class="theme-preview-chip secondary"></div>
                                <div class="theme-preview-chip bg"></div>
                                <div class="theme-preview-chip text"></div>
                            </div>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label" for="background-preset-select">Background Preset</label>
                            <select id="background-preset-select" class="settings-input">
                                <option value="none">None (Use theme colors only)</option>
                                <option value="dark-grid">Hex Grid (Default)</option>
                                <option value="night-city">Night City Skyline</option>
                                <option value="neon-grid">Neon Grid Streets</option>
                                <option value="racing-f1">Racing - F1 Highlights</option>
                                <option value="racing-rally">Racing - Rally Action</option>
                                <option value="racing-motogp">Racing - MotoGP Onboard</option>
                            </select>
                            <span class="form-help">
                                - Static presets above apply instantly as a live preview.
                            </span>
                        </div>

                        <div class="settings-group">
                            <div class="background-mode-options">
                                <label>
                                    <input type="radio" name="custom-bg-mode" value="none" checked>
                                    <span>Default Pattern</span>
                                </label>
                                <label>
                                    <input type="radio" name="custom-bg-mode" value="image">
                                    <span>Image URL</span>
                                </label>
                                <label>
                                    <input type="radio" name="custom-bg-mode" value="youtube">
                                    <span>YouTube Video</span>
                                </label>
                            </div>

                            <div class="settings-group compact">
                                <label class="settings-label" for="custom-bg-url">Custom Background Source</label>
                                <input type="url" id="custom-bg-url" class="settings-input" placeholder="Paste image URL or YouTube URL for background">
                                <span class="form-help">
                                    - Static presets above apply instantly as a live preview.
                                    - For custom: use image (jpg, png, webp, svg, etc.) or a full YouTube URL.
                                </span>
                            </div>
                        </div>
                    </div>
                `;
            case 'offline':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="offline" role="tabpanel" aria-labelledby="settings-tab-offline">
                        <div class="tab-header">
                            <h3 id="settings-tab-offline">
                                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17,8 12,3 7,8"/><line x1="12" y1="3" x2="12" y2="15"/>
                                </svg>
                                Offline Mode
                            </h3>
                            <p>Cache games and assets for offline play when you lose internet connection.</p>
                        </div>

                        <div class="settings-group critical offline-mode-group">
                            <div class="offline-mode-toggle-wrapper">
                                <div class="offline-mode-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17,8 12,3 7,8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                </div>
                                <div class="offline-mode-content">
                                    <label class="settings-label offline-mode-label">
                                        <label class="switch-container">
                                            <input type="checkbox" id="offline-mode-toggle" class="setting-checkbox">
                                            <span class="switch-slider"></span>
                                        </label>
                                        Enable Offline Mode
                                    </label>
                                    <span class="form-help">
                                        Automatically caches core assets and selected games for uninterrupted play without internet.
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div class="offline-split-view">
                            <div class="offline-left-section">
                                <div class="cached-games-header">
                                    <div class="cached-games-header-content">
                                        <h4>
                                            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                                            </svg>
                                            Cached Games
                                        </h4>
                                        <div class="cache-statistics">
                                            <div class="cache-stat">
                                                <span class="cache-stat-value" id="cache-games-count">0</span>
                                                <span class="cache-stat-label">games cached</span>
                                            </div>
                                            <div class="cache-stat">
                                                <span class="cache-stat-value" id="cache-total-size">0 MB</span>
                                                <span class="cache-stat-label">total size</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div id="cached-games-list" class="cached-games-cards">
                                    <div class="no-games">
                                        <div class="no-games-icon">📦</div>
                                        <h5>No cached games yet</h5>
                                        <p>Games you select will appear here for offline play</p>
                                    </div>
                                </div>
                            </div>

                            <div class="offline-right-section">
                                <div class="browse-games-section" onclick="window.open('pages/games.html', '_blank')" role="button" tabindex="0">
                                    <div class="browse-games-content">
                                        <div class="browse-games-icon">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <rect width="20" height="14" x="2" y="3" rx="2"/>
                                                <line x1="8" x2="16" y1="21" y2="21"/>
                                                <line x1="12" x2="12" y1="17" y2="21"/>
                                            </svg>
                                        </div>
                                        <h4>Browse & Select Games</h4>
                                        <p>Choose games to cache for offline play</p>
                                        <div class="browse-games-arrow">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <path d="M7 17 17 7M7 7h10v10"/>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            case 'privacy':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="privacy" role="tabpanel" aria-labelledby="settings-tab-privacy">
                        <div class="tab-header">
                            <h3 id="settings-tab-privacy">Privacy</h3>
                            <p>Cloaks, anti-close protection, panic keys, and related privacy behaviors.</p>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label">Tab Cloak</label>
                            <div class="cloak-list" id="cloak-list">
                            </div>
                            <span class="form-help">
                                Changes tab title and icon only. Selection is stored and applied globally.
                            </span>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label">
                                <label class="switch-container">
                                    <input type="checkbox" id="cloak-rotation-toggle" class="setting-checkbox">
                                    <span class="switch-slider"></span>
                                </label>
                                Rotating Cloaks
                                <span id="cloak-rotation-indicator" class="rotation-indicator" style="display: none;">🔄</span>
                            </label>
                            <div id="cloak-rotation-settings" class="rotation-settings" style="display: none;">
                                <div class="settings-group compact">
                                    <label class="settings-label" for="cloak-rotation-interval">Rotation Interval</label>
                                    <input type="range" id="cloak-rotation-interval" class="settings-input" min="0.5" max="10" step="0.5" value="1.0">
                                    <span class="form-help">
                                        <span id="rotation-interval-value">1.0s</span> - Time between cloak changes (0.5-10 seconds)
                                    </span>
                                </div>
                            </div>
                            <span class="form-help">
                                Automatically cycle through available cloaks at the specified interval.
                            </span>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label">Custom Cloaks</label>
                            <div class="custom-cloak-input">
                                <input type="text" id="custom-cloak-title" class="settings-input" placeholder="Tab Title" maxlength="100">
                                <input type="url" id="custom-cloak-icon" class="settings-input" placeholder="Favicon URL">
                                <button type="button" id="add-custom-cloak-btn" class="btn btn-secondary">Add</button>
                            </div>
                            <div id="custom-cloaks-list" class="custom-cloaks-list">
                            </div>
                            <span class="form-help">
                                Add custom cloaks with your own title and icon. Preview shows how they'll appear.
                            </span>
                        </div>

                        <div class="settings-group info">
                            <label class="settings-label" for="cloak-mode-select">Cloak Mode</label>
                            <select id="cloak-mode-select" class="settings-input">
                                <option value="none">None</option>
                                <option value="blob">Blob tab</option>
                                <option value="about:blank">About:blank</option>
                            </select>
                            <span class="form-help">
                                Select a single cloaking behavior: About:Blank or Blob Tab.
                            </span>
                        </div>

                        <div class="settings-group critical">
                            <label class="settings-label">
                                <label class="switch-container">
                                    <input type="checkbox" id="anti-close-toggle" class="setting-checkbox">
                                    <span class="switch-slider"></span>
                                </label>
                                Anti-close Protection
                            </label>
                            <span class="form-help">
                                When enabled, warns before closing the tab.
                            </span>
                        </div>

                        <div class="settings-group critical">
                            <label class="settings-label" for="panic-keys-select">Panic Keys</label>
                            <select id="panic-keys-select" class="settings-input">
                                <option value="none">None</option>
                                <option value="ctrl+shift+k">Ctrl+Shift+K</option>
                                <option value="ctrl+shift+x">Ctrl+Shift+X</option>
                                <option value="custom">Custom...</option>
                            </select>
                            <div id="custom-panic-settings" class="custom-panic-settings" style="display: none;">
                                <div class="settings-group compact">
                                    <label class="settings-label" for="custom-panic-key">Custom Key Combination</label>
                                    <input type="text" id="custom-panic-key" class="settings-input" placeholder="Press keys..." readonly>
                                    <button type="button" id="set-custom-panic-key" class="btn btn-secondary">Set Key</button>
                                    <span class="form-help">Click "Set Key" and press your desired key combination.</span>
                                </div>
                                <div class="settings-group compact">
                                    <label class="settings-label" for="custom-panic-url">Custom Redirect URL</label>
                                    <input type="url" id="custom-panic-url" class="settings-input" placeholder="https://example.com">
                                    <span class="form-help">URL to redirect to when panic keys are pressed.</span>
                                </div>
                            </div>
                            <span class="form-help">
                                Triggers a fast safety action when pressed.
                            </span>
                        </div>
                    </div>
                `;
            case 'ai':
                return `
                    <div class="settings-tab ${isActive ? 'active' : ''}" data-tab="ai" role="tabpanel" aria-labelledby="settings-tab-ai">
                        <div class="tab-header">
                            <h3 id="settings-tab-ai">AI Settings</h3>
                            <p>Configure AI model parameters and conversation settings.</p>
                        </div>

                        <div class="settings-section">
                            <h4>Model Configuration</h4>
                            <div class="settings-group">
                                <label class="settings-label" for="ai-temperature-slider">
                                    <span class="setting-name">Model Temperature</span>
                                    <span class="setting-description">Controls randomness in AI responses</span>
                                </label>
                                <div class="control-group">
                                    <div class="range-wrapper">
                                        <input
                                            type="range"
                                            id="ai-temperature-slider"
                                            min="0"
                                            max="1"
                                            step="0.1"
                                            value="0.7"
                                            class="settings-input"
                                        >
                                        <span class="settings-value" id="ai-temperature-value">0.7</span>
                                    </div>
                                    <div class="range-labels">
                                        <span>Conservative</span>
                                        <span>Creative</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Conversation Settings</h4>
                            <div class="settings-group">
                                <label class="settings-label">
                                    <div class="setting-info">
                                        <span class="setting-name">Auto-save Conversations</span>
                                        <span class="setting-description">Automatically save conversations to local storage as you chat</span>
                                    </div>
                                    <label class="switch-container">
                                        <input type="checkbox" id="ai-auto-save-toggle" class="setting-checkbox" checked>
                                        <span class="switch-slider"></span>
                                    </label>
                                </label>
                            </div>
                            <div class="settings-group">
                                <label class="settings-label" for="ai-clear-conversations-btn">
                                    <span class="setting-name">Clear Conversations</span>
                                    <span class="setting-description">Remove all saved conversations from local storage</span>
                                </label>
                                <button class="btn btn-secondary" id="ai-clear-conversations-btn">
                                    Clear All Conversations
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            default:
                return '';
        }
    }

    createModal() {
        const modal = document.createElement('div');
        modal.className = 'settings-modal-overlay hidden';
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-labelledby', 'settings-modal-title');
        modal.innerHTML = `
            <div class="settings-modal-container" tabindex="-1">
                <!-- Modal Header -->
                <div class="settings-header">
                    <h2 class="settings-title" id="settings-modal-title">
                        <svg class="title-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                        Settings
                    </h2>
                    <button class="settings-close-btn" id="settings-close-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M18 6 6 18M6 6l12 12"/>
                        </svg>
                    </button>
                </div>

                <!-- Modal Content -->
                <div class="settings-content">
                    <!-- Sidebar Navigation -->
                    <div class="settings-sidebar">
                        <nav class="settings-nav" role="tablist">
                            ${this.generateNavigationHTML()}
                        </nav>
                    </div>

                    <!-- Settings Forms -->
                    <div class="settings-main">
                        ${this.generateTabContentHTML()}

                        <!-- Appearance Tab -->
                        <div class="settings-tab" data-tab="appearance" role="tabpanel" aria-labelledby="settings-tab-appearance">
                            <div class="tab-header">
                                <h3 id="settings-tab-appearance">Appearance</h3>
                                <p>Theme presets and custom colors. Changes apply instantly to the UI.</p>
                            </div>

                            <!-- Theme presets -->
                            <div class="settings-group">
                                <label class="settings-label" for="theme-preset-select">Theme Preset</label>
                                <select id="theme-preset-select" class="settings-input">
                                    <option value="dark">Dark</option>
                                    <option value="ocean">Ocean</option>
                                    <option value="forest">Forest</option>
                                    <option value="custom">Custom (use colors below)</option>
                                </select>
                                <span class="form-help">Pick a base theme or choose Custom and tune the colors below.</span>
                            </div>

                            <!-- Global Color Thief Toggle -->
                            <div class="settings-group info">
                                <label class="settings-label">
                                    <label class="switch-container">
                                        <input type="checkbox" id="global-color-thief-toggle" class="setting-checkbox">
                                        <span class="switch-slider"></span>
                                    </label>
                                    Enable Global Color Thief
                                </label>
                                <span class="form-help">
                                    Automatically extract dominant colors from album art, posters, and other images to create dynamic themes.
                                </span>
                            </div>

                            <!-- Custom Theme Editor -->
                            <div class="settings-group info">
                                <div class="tab-subheader">
                                    <h4>Custom Theme</h4>
                                    <p>Tweak core colors. Values must be valid hex codes (e.g. #0d0d0d or #fff).</p>
                                </div>

                                <div class="custom-theme-grid">
                                    <div class="custom-theme-field">
                                        <label class="settings-label" for="theme-primary-color">Primary Color</label>
                                        <div class="color-picker-group">
                                            <input type="color" id="theme-primary-color" class="color-picker">
                                            <input type="text" id="theme-primary-color-text" class="settings-input theme-color-input" placeholder="#a1a1a6" maxlength="7">
                                        </div>
                                        <span class="form-help">Used for highlights and primary accents.</span>
                                    </div>

                                    <div class="custom-theme-field">
                                        <label class="settings-label" for="theme-secondary-color">Secondary Color</label>
                                        <div class="color-picker-group">
                                            <input type="color" id="theme-secondary-color" class="color-picker">
                                            <input type="text" id="theme-secondary-color-text" class="settings-input theme-color-input" placeholder="#ffffff" maxlength="7">
                                        </div>
                                        <span class="form-help">Used for subtle accents and borders.</span>
                                    </div>

                                    <div class="custom-theme-field">
                                        <label class="settings-label" for="theme-bg-color">Background Color</label>
                                        <div class="color-picker-group">
                                            <input type="color" id="theme-bg-color" class="color-picker">
                                            <input type="text" id="theme-bg-color-text" class="settings-input theme-color-input" placeholder="#0d0d0d" maxlength="7">
                                        </div>
                                        <span class="form-help">Base background behind the hex pattern.</span>
                                    </div>

                                    <div class="custom-theme-field">
                                        <label class="settings-label" for="theme-text-color">Text Color</label>
                                        <div class="color-picker-group">
                                            <input type="color" id="theme-text-color" class="color-picker">
                                            <input type="text" id="theme-text-color-text" class="settings-input theme-color-input" placeholder="#ffffff" maxlength="7">
                                        </div>
                                        <span class="form-help">Primary text color for content.</span>
                                    </div>
                                </div>

                                <div class="theme-preview-banner" id="theme-preview">
                                    <div class="theme-preview-label">Preview swatches</div>
                                    <div class="theme-preview-chip primary"></div>
                                    <div class="theme-preview-chip secondary"></div>
                                    <div class="theme-preview-chip bg"></div>
                                    <div class="theme-preview-chip text"></div>
                                </div>
                            </div>

                            <!-- Predefined background options -->
                            <div class="settings-group">
                                <label class="settings-label" for="background-preset-select">Background Preset</label>
                                <select id="background-preset-select" class="settings-input">
                                    <option value="none">None (Use theme colors only)</option>
                                    <option value="dark-grid">Hex Grid (Default)</option>
                                    <option value="night-city">Night City Skyline</option>
                                    <option value="neon-grid">Neon Grid Streets</option>
                                    <option value="racing-f1">Racing - F1 Highlights</option>
                                    <option value="racing-rally">Racing - Rally Action</option>
                                    <option value="racing-motogp">Racing - MotoGP Onboard</option>
                                </select>
                                <span class="form-help">
                                    - Static presets above apply instantly as a live preview.
                                </span>
                            </div>

                            <!-- Custom mode + URL (image or YouTube; applies to real background, no inline player) -->
                            <div class="settings-group">
                                <div class="background-mode-options">
                                    <label>
                                        <input type="radio" name="custom-bg-mode" value="none" checked>
                                        <span>Default Pattern</span>
                                    </label>
                                    <label>
                                        <input type="radio" name="custom-bg-mode" value="image">
                                        <span>Image URL</span>
                                    </label>
                                    <label>
                                        <input type="radio" name="custom-bg-mode" value="youtube">
                                        <span>YouTube Video</span>
                                    </label>
                                </div>

                                <div class="settings-group compact">
                                    <label class="settings-label" for="custom-bg-url">Custom Background Source</label>
                                    <input type="url" id="custom-bg-url" class="settings-input" placeholder="Paste image URL or YouTube URL for background">
                                    <span class="form-help">
                                        - Static presets above apply instantly as a live preview.
                                        - For custom: use image (jpg, png, webp, svg, etc.) or a full YouTube URL.
                                    </span>
                                </div>
                            </div>
                        </div>


                        <!-- Offline Tab -->
                        <div class="settings-tab" data-tab="offline" role="tabpanel" aria-labelledby="settings-tab-offline">
                            <div class="tab-header">
                                <h3 id="settings-tab-offline">Offline</h3>
                                <p>Control offline mode and cached games.</p>
                            </div>

                            <!-- Offline toggle -->
                            <div class="settings-group critical">
                                <label class="settings-label">
                                    <label class="switch-container">
                                        <input type="checkbox" id="offline-mode-toggle" class="setting-checkbox">
                                        <span class="switch-slider"></span>
                                    </label>
                                    Enable Offline Mode
                                </label>
                                <span class="form-help">
                                    Caches core assets and selected games so they keep working when you lose connection.
                                </span>
                            </div>

                            <!-- Split-view Layout -->
                            <div class="offline-split-view">
                                <!-- Left Section: Cached Games -->
                                <div class="offline-left-section">
                                    <div class="cached-games-header">
                                        <h4>Cached Games</h4>
                                        <div class="cache-statistics">
                                            <span id="cache-games-count">0</span> games cached •
                                            <span id="cache-total-size">0 MB</span> total
                                        </div>
                                    </div>
                                    <div id="cached-games-list" class="cached-games-cards">
                                        <div class="no-games">No cached games</div>
                                    </div>
                                </div>

                                <!-- Right Section: Browse Games -->
                                <div class="offline-right-section">
                                    <div class="browse-games-section" onclick="window.open('pages/games.html', '_blank')">
                                        <div class="browse-games-content">
                                            <div class="browse-games-icon">🎮</div>
                                            <h4>Click to browse all games</h4>
                                            <p>Select games to cache for offline play</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <!-- AI Tab -->
                        <div class="settings-tab" data-tab="ai" role="tabpanel" aria-labelledby="settings-tab-ai">
                            <div class="tab-header">
                                <h3 id="settings-tab-ai">AI Settings</h3>
                                <p>Configure AI model parameters and conversation settings.</p>
                            </div>

                            <div class="settings-section">
                                <h4>Model Configuration</h4>
                                <div class="settings-group">
                                    <label class="settings-label" for="ai-temperature-slider">
                                        <span class="setting-name">Model Temperature</span>
                                        <span class="setting-description">Controls randomness in AI responses</span>
                                    </label>
                                    <div class="control-group">
                                        <div class="range-wrapper">
                                            <input
                                                type="range"
                                                id="ai-temperature-slider"
                                                min="0"
                                                max="1"
                                                step="0.1"
                                                value="0.7"
                                                class="settings-input"
                                            >
                                            <span class="settings-value" id="ai-temperature-value">0.7</span>
                                        </div>
                                        <div class="range-labels">
                                            <span>Conservative</span>
                                            <span>Creative</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="settings-section">
                                <h4>Conversation Settings</h4>
                                <div class="settings-group">
                                    <label class="settings-label">
                                        <div class="setting-info">
                                            <span class="setting-name">Auto-save Conversations</span>
                                            <span class="setting-description">Automatically save conversations to local storage as you chat</span>
                                        </div>
                                        <label class="switch-container">
                                            <input type="checkbox" id="ai-auto-save-toggle" class="setting-checkbox" checked>
                                            <span class="switch-slider"></span>
                                        </label>
                                    </label>
                                </div>
                                <div class="settings-group">
                                    <label class="settings-label" for="ai-clear-conversations-btn">
                                        <span class="setting-name">Clear Conversations</span>
                                        <span class="setting-description">Remove all saved conversations from local storage</span>
                                    </label>
                                    <button class="btn btn-secondary" id="ai-clear-conversations-btn">
                                        Clear All Conversations
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Privacy Tab -->
                        <div class="settings-tab" data-tab="privacy" role="tabpanel" aria-labelledby="settings-tab-privacy">
                            <div class="tab-header">
                                <h3 id="settings-tab-privacy">Privacy</h3>
                                <p>Cloaks, anti-close protection, panic keys, and related privacy behaviors.</p>
                            </div>

                            <!-- Cloak selection -->
                            <div class="settings-group info">
                                <label class="settings-label">Tab Cloak</label>
                                <div class="cloak-list" id="cloak-list">
                                    <!-- Populated from this.cloaks -->
                                </div>
                                <span class="form-help">
                                    Changes tab title and icon only. Selection is stored and applied globally.
                                </span>
                            </div>

                            <!-- Rotating Cloaks -->
                            <div class="settings-group info">
                                <label class="settings-label">
                                    <label class="switch-container">
                                        <input type="checkbox" id="cloak-rotation-toggle" class="setting-checkbox">
                                        <span class="switch-slider"></span>
                                    </label>
                                    Rotating Cloaks
                                    <span id="cloak-rotation-indicator" class="rotation-indicator" style="display: none;">🔄</span>
                                </label>
                                <span class="form-help">
                                    Automatically cycle through available cloaks at the specified interval.
                                </span>
                                <div id="cloak-rotation-settings" class="rotation-settings" style="display: none;">
                                    <div class="settings-group compact">
                                        <label class="settings-label" for="cloak-rotation-interval">Rotation Interval</label>
                                        <input type="range" id="cloak-rotation-interval" class="settings-input" min="0.5" max="10" step="0.5" value="1.0">
                                        <span class="settings-value" id="rotation-interval-value">1.0s</span>
                                        <div class="range-labels">
                                            <span>Fast</span>
                                            <span>Slow</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Custom Cloaks -->
                            <div class="settings-group info">
                                <label class="settings-label">Custom Cloaks</label>
                                <div class="custom-cloak-input">
                                    <input type="text" id="custom-cloak-title" class="settings-input" placeholder="Tab Title" maxlength="100">
                                    <input type="url" id="custom-cloak-icon" class="settings-input" placeholder="Favicon URL">
                                    <button type="button" id="add-custom-cloak-btn" class="btn btn-secondary">Add</button>
                                </div>
                                <div id="custom-cloaks-list" class="custom-cloaks-list">
                                    <!-- Custom cloaks will be populated here -->
                                </div>
                                <span class="form-help">
                                    Add custom cloaks with your own title and icon. Preview shows how they'll appear.
                                </span>
                            </div>

                            <!-- Cloak mode -->
                            <div class="settings-group info">
                                <label class="settings-label" for="cloak-mode-select">Cloak Mode</label>
                                <select id="cloak-mode-select" class="settings-input">
                                    <option value="none">None</option>
                                    <option value="blob">Blob tab</option>
                                    <option value="about:blank">About:blank</option>
                                </select>
                                <span class="form-help">
                                    Select a single cloaking behavior: About:Blank or Blob Tab.
                                </span>
                            </div>

                            <!-- Anti-close -->
                            <div class="settings-group critical">
                                <label class="settings-label">
                                    <label class="switch-container">
                                        <input type="checkbox" id="anti-close-toggle" class="setting-checkbox">
                                        <span class="switch-slider"></span>
                                    </label>
                                    Anti-close Protection
                                </label>
                                <span class="form-help">
                                    When enabled, warns before closing the tab.
                                </span>
                            </div>

                            <!-- Panic Keys -->
                            <div class="settings-group critical">
                                <label class="settings-label" for="panic-keys-select">Panic Keys</label>
                                <select id="panic-keys-select" class="settings-input">
                                    <option value="none">None</option>
                                    <option value="ctrl+shift+k">Ctrl+Shift+K</option>
                                    <option value="ctrl+shift+x">Ctrl+Shift+X</option>
                                    <option value="custom">Custom...</option>
                                </select>
                                <div id="custom-panic-settings" class="custom-panic-settings" style="display: none;">
                                    <div class="settings-group compact">
                                        <label class="settings-label" for="custom-panic-key">Custom Key Combination</label>
                                        <input type="text" id="custom-panic-key" class="settings-input" placeholder="Press keys..." readonly>
                                        <button type="button" id="set-custom-panic-key" class="btn btn-secondary">Set Key</button>
                                        <span class="form-help">Click "Set Key" and press your desired key combination.</span>
                                    </div>
                                    <div class="settings-group compact">
                                        <label class="settings-label" for="custom-panic-url">Custom Redirect URL</label>
                                        <input type="url" id="custom-panic-url" class="settings-input" placeholder="https://example.com">
                                        <span class="form-help">URL to redirect to when panic keys are pressed.</span>
                                    </div>
                                </div>
                                <span class="form-help">
                                    Triggers a fast safety action when pressed.
                                </span>
                            </div>
                        </div>

                    </div>
                </div>

                <!-- Modal Footer -->
                <div class="settings-footer">
                    <div class="settings-autosave-note" aria-live="polite">
                        Settings save automatically as you change them.
                    </div>
                    <button type="button" id="cancel-settings" class="btn btn-secondary">Close</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        this.modal = modal;
        this.cacheElements();
        SettingsModal.initSlider('ai-temperature-slider');
    }

    cacheElements() {
        if (!this.modal) {
            console.warn('SettingsModal modal not found, skipping element caching');
            return;
        }

        const safeQuery = (selector) => {
            try {
                return this.modal.querySelector(selector);
            } catch (error) {
                console.warn(`Failed to query element ${selector}:`, error);
                return null;
            }
        };

        const safeQueryAll = (selector) => {
            try {
                return this.modal.querySelectorAll(selector);
            } catch (error) {
                console.warn(`Failed to query elements ${selector}:`, error);
                return [];
            }
        };

        this.elements = {
            closeBtn: safeQuery('#settings-close-btn'),
            cancelBtn: safeQuery('#cancel-settings'),

            // Movies settings
            maxRatingSelect: safeQuery('#max-rating-select'),
            hideNcNrToggle: safeQuery('#hide-nc-nr-toggle'),
            moviesProxyEnabledToggle: safeQuery('#movies-proxy-enabled-toggle'),

            // Navigation
            navItems: safeQueryAll('.settings-nav-item'),
            tabs: safeQueryAll('.settings-tab'),

            // Library
            librarySelect: safeQuery('#library-select'),

            // Offline
            offlineModeToggle: safeQuery('#offline-mode-toggle'),
            cachedGamesList: safeQuery('#cached-games-list'),
            cacheGamesCount: safeQuery('#cache-games-count'),
            cacheTotalSize: safeQuery('#cache-total-size'),

            // Appearance
            themePresetSelect: safeQuery('#theme-preset-select'),
            backgroundPresetSelect: safeQuery('#background-preset-select'),
            customBgUrl: safeQuery('#custom-bg-url'),
            customBgModeRadios: safeQueryAll('input[name="custom-bg-mode"]'),
            themePreviewChips: safeQueryAll('#theme-preview .theme-preview-chip'),
            // Custom theme editor
            primaryColor: safeQuery('#theme-primary-color'),
            primaryColorText: safeQuery('#theme-primary-color-text'),
            secondaryColor: safeQuery('#theme-secondary-color'),
            secondaryColorText: safeQuery('#theme-secondary-color-text'),
            bgColor: safeQuery('#theme-bg-color'),
            bgColorText: safeQuery('#theme-bg-color-text'),
            textColor: safeQuery('#theme-text-color'),
            textColorText: safeQuery('#theme-text-color-text'),
            themePreview: safeQuery('#theme-preview'),

            // Privacy (cloak + safety)
            cloakModeSelect: safeQuery('#cloak-mode-select'),
            antiCloseToggle: safeQuery('#anti-close-toggle'),
            panicKeysSelect: safeQuery('#panic-keys-select'),
            cloakList: safeQuery('#cloak-list'),

            // AI settings
            aiTemperatureSlider: safeQuery('#ai-temperature-slider'),
            aiTemperatureValue: safeQuery('#ai-temperature-value'),
            aiAutoSaveToggle: safeQuery('#ai-auto-save-toggle'),
            aiClearConversationsBtn: safeQuery('#ai-clear-conversations-btn'),

            // Global Color Thief
            globalColorThiefToggle: safeQuery('#global-color-thief-toggle'),

            // WidgetBot
            widgetbotEnabledToggle: safeQuery('#widgetbot-enabled-toggle'),

            // Custom Panic Keys
            customPanicSettings: safeQuery('#custom-panic-settings'),
            customPanicKey: safeQuery('#custom-panic-key'),
            setCustomPanicKey: safeQuery('#set-custom-panic-key'),
            customPanicUrl: safeQuery('#custom-panic-url'),


            // Cloak Rotation
            cloakRotationToggle: safeQuery('#cloak-rotation-toggle'),
            cloakRotationIndicator: safeQuery('#cloak-rotation-indicator'),
            cloakRotationSettings: safeQuery('#cloak-rotation-settings'),
            cloakRotationInterval: safeQuery('#cloak-rotation-interval'),
            rotationIntervalValue: safeQuery('#rotation-interval-value'),
            customCloakTitle: safeQuery('#custom-cloak-title'),
            customCloakIcon: safeQuery('#custom-cloak-icon'),
            addCustomCloakBtn: safeQuery('#add-custom-cloak-btn'),
            customCloaksList: safeQuery('#custom-cloaks-list')
        };

        // Note: avoid noisy console logs in production; use errors/warnings only when needed.
    }

    bindEvents() {
        // Navigation
        if (this.elements.navItems && this.elements.navItems.length > 0) {
            this.elements.navItems.forEach(item => {
                if (!item) return;
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.switchTab(item.dataset.tab);
                });
            });
        }

        // Modal controls
        if (this.elements.closeBtn) {
            this.elements.closeBtn.addEventListener('click', () => this.close());
        }
        if (this.elements.cancelBtn) {
            this.elements.cancelBtn.addEventListener('click', () => this.close());
        }

        // Close on overlay click (only when clicking true backdrop)
        if (this.modal) {
            this.modal.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.close();
                }
            });
        }

        // Keyboard shortcuts while modal is open
        document.addEventListener('keydown', (e) => {
            if (!this.isOpen) return;

            // Always allow ESC to close
            if (e.key === 'Escape') {
                e.preventDefault();
                this.close();
                return;
            }
        });

        // Library selection
        if (this.elements.librarySelect) {
            this.elements.librarySelect.addEventListener('change', (e) => {
                const libraryType = e.target.value;
                const libraryUrl = libraryType === 'default' ? 'components/zones.json' : 'components/zones2.json';
                this.selectLibrary(libraryType, libraryUrl);

                // Dispatch event for games.html to listen
                window.dispatchEvent(new CustomEvent('alternateGameLibraryChanged', {
                    detail: { enabled: libraryType === 'alt' }
                }));
            });
        }

        // Cached games list interactions
        if (this.elements.cachedGamesList) {
            this.elements.cachedGamesList.addEventListener('click', (e) => {
                if (e.target && e.target.matches('.btn-remove-game')) {
                    const gameId = e.target.closest('.cached-game-item').dataset.gameId;
                    this.removeCachedGame(gameId);
                }
            });
        }

        // Custom theme editor bindings (live preview + debounced persist)
        const bindColorPair = (picker, text, cssVar) => {
            if (!picker || !text) return;

            const applyLive = (value, fromPicker = false) => {
                if (this.isValidColor(value)) {
                    picker.value = value;
                    text.value = value;
                    document.documentElement.style.setProperty(cssVar, value);
                    this.setFieldValidity(text, true);
                    this.updateThemePreviewChips();

                    // Any direct color change promotes the preset to "custom"
                    if (this.elements.themePresetSelect && this.elements.themePresetSelect.value !== 'custom') {
                        this.elements.themePresetSelect.value = 'custom';
                    }

                    // Ensure settings object exists and reflect custom mode
                    this.settings = this.settings || this.getDefaultSettings();
                    this.settings.themePreset = 'custom';

                    switch (cssVar) {
                        case '--primary-color':
                            this.settings.primaryColor = value;
                            break;
                        case '--secondary-color':
                            this.settings.secondaryColor = value;
                            break;
                        case '--background-color':
                            this.settings.backgroundColor = value;
                            break;
                        case '--text-color':
                            this.settings.textColor = value;
                            break;
                    }

                    // Use debounced application so collect/persist run reliably
                    this.debounceThemeApplication();
                } else if (!fromPicker) {
                    this.setFieldValidity(text, false);
                }
            };

            picker.addEventListener('input', (e) => applyLive(e.target.value, true));
            text.addEventListener('input', (e) => applyLive(e.target.value));
        };

        bindColorPair(this.elements.primaryColor, this.elements.primaryColorText, '--primary-color');
        bindColorPair(this.elements.secondaryColor, this.elements.secondaryColorText, '--secondary-color');
        bindColorPair(this.elements.bgColor, this.elements.bgColorText, '--background-color');
        bindColorPair(this.elements.textColor, this.elements.textColorText, '--text-color');

        // Background preset dropdown: maps to static and racing video backgrounds (no live iframe here)
        if (this.elements.backgroundPresetSelect) {
            this.elements.backgroundPresetSelect.addEventListener('change', () => {
                const value = this.elements.backgroundPresetSelect.value;
                let customBgConfig = null;

                switch (value) {
                    case 'none':
                        customBgConfig = { type: 'none' }; // solid color only
                        break;
                    case 'dark-grid':
                        customBgConfig = null; // use default CSS hex grid
                        break;
                    case 'night-city':
                        customBgConfig = { type: 'image', url: 'https://images.pexels.com/photos/2837009/pexels-photo-2837009.jpeg?auto=compress&cs=tinysrgb&w=1600' };
                        break;
                    case 'neon-grid':
                        customBgConfig = { type: 'image', url: 'https://images.pexels.com/photos/1322185/pexels-photo-1322185.jpeg?auto=compress&cs=tinysrgb&w=1600' };
                        break;
                    case 'racing-f1':
                        customBgConfig = { type: 'youtube', videoId: '2x5bT-k64hA' };
                        break;
                    case 'racing-rally':
                        customBgConfig = { type: 'youtube', videoId: 'dR2vR8VnXj0' };
                        break;
                    case 'racing-motogp':
                        customBgConfig = { type: 'youtube', videoId: 'z4zE8ApsW6s' };
                        break;
                    default:
                        customBgConfig = null;
                }

                const presetKey = (this.elements.themePresetSelect && this.elements.themePresetSelect.value) || 'dark';
                this.applyThemePreset(presetKey, customBgConfig || null);

                // Sync radio + URL for custom modes when appropriate
                if (this.elements.customBgModeRadios && this.elements.customBgUrl) {
                    if (!customBgConfig) {
                        this.elements.customBgModeRadios.forEach(r => { r.checked = r.value === 'none'; });
                        this.elements.customBgUrl.value = '';
                    } else if (customBgConfig.type === 'image') {
                        this.elements.customBgModeRadios.forEach(r => { r.checked = r.value === 'image'; });
                        this.elements.customBgUrl.value = customBgConfig.url;
                    } else if (customBgConfig.type === 'youtube') {
                        this.elements.customBgModeRadios.forEach(r => { r.checked = r.value === 'youtube'; });
                        this.elements.customBgUrl.value = `https://www.youtube.com/watch?v=${customBgConfig.videoId}`;
                    }
                }

                // Persist new settings
                const updated = this.collectSettings();
                this.persistSettings(updated);
            });
        }

        // Custom background handling (no embedded live preview: only apply theme/background)
        if (this.elements.customBgModeRadios && this.elements.customBgUrl) {
            const applyBackgroundConfig = () => {
                const rawUrl = this.elements.customBgUrl.value.trim();
                let mode = 'none';
                this.elements.customBgModeRadios.forEach(r => {
                    if (r.checked) mode = r.value;
                });

                let url = rawUrl;
                // Auto-convert YouTube watch URLs to embed-compatible videoId
                let config = null;
                if (mode === 'image' && url && this.isLikelyImageUrl(url)) {
                    config = { type: 'image', url };
                } else if (mode === 'youtube' && url) {
                    const id = this.extractYouTubeVideoId(url);
                    if (id) {
                        config = { type: 'youtube', videoId: id };
                    }
                }

                const presetKey = (this.elements.themePresetSelect && this.elements.themePresetSelect.value) || 'dark';
                this.applyThemePreset(presetKey, config || null);

                // Persist immediately for consistent behavior across pages
                const updated = this.collectSettings();
                this.persistSettings(updated);
            };

            this.elements.customBgModeRadios.forEach(r => {
                r.addEventListener('change', applyBackgroundConfig);
            });
            this.elements.customBgUrl.addEventListener('input', applyBackgroundConfig);
        }

        // Initialize cloak list in Privacy tab
        if (this.elements.cloakList) {
            this.renderCloakList();
        }

        // Initialize cloak rotation settings (wait for rotation manager to be ready)
        setTimeout(() => {
            this.initializeCloakRotationUI();
            this.initializeCloakRotationToggleBehavior();
        }, 100);

        // Initialize global color thief toggle
        this.initializeGlobalColorThief();

        // Initialize custom panic keys
        this.initializeCustomPanicKeys();


        // Initialize current library display
        this.updateCurrentLibraryDisplay();

        // Auto-save bindings: listen to changes on core inputs
        const autoSaveTargets = [
            this.elements.themePresetSelect,
            this.elements.customBgUrl,
            this.elements.primaryLibrarySelect,
            this.elements.altLibrarySelect,
            this.elements.offlineModeToggle,
            this.elements.antiCloseToggle,
            this.elements.panicKeysSelect,
            this.elements.cloakModeSelect,
            this.elements.globalColorThiefToggle,
            this.elements.widgetbotEnabledToggle,
            this.elements.maxRatingSelect,
            this.elements.moviesProxyEnabledToggle
        ];
    
            autoSaveTargets.forEach(el => {
                if (!el) return;
                const eventName = (el.tagName === 'SELECT' || el.type === 'checkbox' || el.type === 'radio') ? 'change' : 'input';
                el.addEventListener(eventName, () => this.autoSaveFromEvent());
            });
    
            if (this.elements.customBgModeRadios && this.elements.customBgModeRadios.length) {
                this.elements.customBgModeRadios.forEach(radio => {
                    radio.addEventListener('change', () => this.autoSaveFromEvent());
                });
            }
    
            if (this.elements.offlineGamesList) {
                this.elements.offlineGamesList.addEventListener('change', () => this.autoSaveFromEvent());
            }
    
            // Cloak mode dropdown auto-save
            if (this.elements.cloakModeSelect) {
                this.elements.cloakModeSelect.addEventListener('change', () => this.autoSaveFromEvent());
            }
    
            // Cloak rotation auto-save
            if (this.elements.cloakRotationToggle) {
                this.elements.cloakRotationToggle.addEventListener('change', () => this.autoSaveFromEvent());
            }
    
            if (this.elements.cloakRotationInterval) {
                this.elements.cloakRotationInterval.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (this.elements.rotationIntervalValue) {
                        this.elements.rotationIntervalValue.textContent = `${value}s`;
                    }
                    this.autoSaveFromEvent();
                });
            }

            // AI settings auto-save
            if (this.elements.aiTemperatureSlider) {
                this.elements.aiTemperatureSlider.addEventListener('input', () => {
                    if (this.elements.aiTemperatureValue) {
                        this.elements.aiTemperatureValue.textContent = this.elements.aiTemperatureSlider.value;
                    }
                    this.autoSaveFromEvent();
                });
            }
            if (this.elements.aiAutoSaveToggle) {
                this.elements.aiAutoSaveToggle.addEventListener('change', () => this.autoSaveFromEvent());
            }
            if (this.elements.aiClearConversationsBtn) {
                this.elements.aiClearConversationsBtn.addEventListener('click', () => this.clearAIConversations());
            }
        }

        clearAIConversations() {
            if (!confirm('Clear all AI conversations? This action cannot be undone.')) {
                return;
            }

            // Clear AI conversations from localStorage
            const STATE_KEY = 'unblockee_ai_state_v1';
            try {
                localStorage.removeItem(STATE_KEY);
                if (window.notify) {
                    window.notify('AI conversations cleared successfully', 'success');
                } else {
                    alert('AI conversations cleared successfully');
                }
                // Dispatch event to notify ai.html to reload
                window.dispatchEvent(new CustomEvent('aiConversationsCleared'));
            } catch (error) {
                console.error('Failed to clear AI conversations:', error);
                if (window.notify) {
                    window.notify('Failed to clear AI conversations', 'error');
                } else {
                    alert('Failed to clear AI conversations');
                }
            }

    }

    // Minimal validation for custom background URL
    setupFormValidation() {
        if (!this.elements.customBgUrl) return;
        this.elements.customBgUrl.addEventListener('blur', () => {
            const value = this.elements.customBgUrl.value.trim();
            if (!value) {
                this.setFieldValidity(this.elements.customBgUrl, true);
                return;
            }
            // Basic URL sanity (do not block non-URL patterns aggressively)
            try {
                new URL(value);
                this.setFieldValidity(this.elements.customBgUrl, true);
            } catch {
                this.setFieldValidity(this.elements.customBgUrl, false);
            }
        });
    }

    setFieldValidity(field, isValid) {
        if (isValid) {
            field.classList.remove('invalid');
        } else {
            field.classList.add('invalid');
        }
    }

    isValidUrl(string) {
        try {
            new URL(string);
            return true;
        } catch (_) {
            return false;
        }
    }

    /**
     * Initialize global color thief toggle integration
     */
    initializeGlobalColorThief() {
        if (!this.elements.globalColorThiefToggle || !window.ColorThiefManager) return;

        // Set initial state
        this.elements.globalColorThiefToggle.checked = window.ColorThiefManager.enabled;

        // Handle toggle changes
        this.elements.globalColorThiefToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                window.ColorThiefManager.enable();
            } else {
                window.ColorThiefManager.disable();
            }
        });

        // Listen for external changes
        document.addEventListener('colorThiefApplied', () => {
            // Could update UI if needed
        });
    }


    /**
     * Initialize custom panic keys functionality
     */
    initializeCustomPanicKeys() {
        if (!this.elements.panicKeysSelect) return;

        // Show/hide custom settings based on selection
        this.elements.panicKeysSelect.addEventListener('change', (e) => {
            if (this.elements.customPanicSettings) {
                this.elements.customPanicSettings.style.display =
                    e.target.value === 'custom' ? 'block' : 'none';
            }
        });

        // Set custom key button
        if (this.elements.setCustomPanicKey) {
            this.elements.setCustomPanicKey.addEventListener('click', () => {
                this.setCustomPanicKey();
            });
        }

        // Load existing custom panic settings
        this.loadCustomPanicSettings();
    }

    /**
     * Update current library display
     */
    updateCurrentLibraryDisplay() {
        if (!this.elements.currentLibraryDisplay) return;

        const primary = localStorage.getItem('unblockee_primaryLibrary') || 'default';
        const alt = localStorage.getItem('unblockee_altLibraryFile') || '';

        let displayText = 'components/zones.json'; // default
        if (primary === 'alt' && alt) {
            displayText = alt;
        }

        this.elements.currentLibraryDisplay.textContent = displayText;
    }

    /**
     * Select a library option
     */
    selectLibrary(libraryType, libraryUrl) {
        if (libraryType === 'default') {
            localStorage.setItem('unblockee_primaryLibrary', 'default');
            localStorage.setItem('unblockee_altLibraryFile', '');
            localStorage.setItem('alternateGameLibraryEnabled', 'false');
        } else if (libraryType === 'alt') {
            localStorage.setItem('unblockee_primaryLibrary', 'alt');
            localStorage.setItem('unblockee_altLibraryFile', libraryUrl);
            localStorage.setItem('alternateGameLibraryEnabled', 'true');
        }

        // Update UI
        this.updateCurrentLibraryDisplay();

        // Reload offline games list with new library
        if (this.currentTab === 'offline') {
            this.loadOfflineGamesIntoList();
        }

        // Update visual indicators
        const libraryOptions = this.modal.querySelectorAll('.library-option');
        libraryOptions.forEach(option => {
            option.classList.remove('selected');
        });

        const selectedOption = this.modal.querySelector(`.library-option[data-library="${libraryType}"]`);
        if (selectedOption) {
            selectedOption.classList.add('selected');
        }

        // Auto-save
        this.autoSaveFromEvent();
    }

    /**
     * Load custom panic key settings
     */
    loadCustomPanicSettings() {
        try {
            const customKey = localStorage.getItem('unblockee_customPanicKey');
            const customUrl = localStorage.getItem('unblockee_customPanicUrl');

            if (this.elements.customPanicKey) {
                this.elements.customPanicKey.value = customKey || 'Press keys...';
            }
            if (this.elements.customPanicUrl && customUrl) {
                this.elements.customPanicUrl.value = customUrl;
            }

            if (this.elements.panicKeysSelect && customKey) {
                this.elements.panicKeysSelect.value = 'custom';
                if (this.elements.customPanicSettings) {
                    this.elements.customPanicSettings.style.display = 'block';
                }
            }
        } catch (error) {
            console.warn('Error loading custom panic settings:', error);
        }
    }

    /**
     * Set custom panic key combination
     */
    setCustomPanicKey() {
        if (!this.elements.customPanicKey) return;

        this.elements.customPanicKey.value = 'Press a key combination...';
        this.elements.customPanicKey.classList.add('recording');

        const keyHandler = (e) => {
            e.preventDefault();
            e.stopPropagation();

            const keys = [];
            if (e.ctrlKey || e.metaKey) keys.push('Ctrl');
            if (e.shiftKey) keys.push('Shift');
            if (e.altKey) keys.push('Alt');

            // Only allow modifier + one non-modifier key
            if (!['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
                keys.push(e.key === ' ' ? 'Space' : e.key);
            }

            if (keys.length >= 2) {
                const keyCombo = keys.join('+');
                this.elements.customPanicKey.value = keyCombo;
                this.elements.customPanicKey.classList.remove('recording');

                // Save to localStorage
                localStorage.setItem('unblockee_customPanicKey', keyCombo);

                document.removeEventListener('keydown', keyHandler, true);
                this.autoSaveFromEvent();
            }
        };

        document.addEventListener('keydown', keyHandler, true);
    }

    // Implement applyCloak and initializeCloakRotation methods
    applyCloak(cloakName) {
        const cloak = this.cloaks.find(c => c.name === cloakName) || this.cloaks[0];
        document.title = cloak.title;

        const existingFavicon = document.querySelector("link[rel*='icon']");
        if (existingFavicon) existingFavicon.remove();

        if (cloak.icon) {
            try {
                const link = document.createElement('link');
                link.rel = 'icon';
                const ext = cloak.icon.split('.').pop().toLowerCase();
                link.type = ext === 'png' ? 'image/png' : ext === 'svg' ? 'image/svg+xml' : 'image/x-icon';
                link.href = cloak.icon + (cloak.icon.includes('?') ? '&' : '?') + 'v=' + Date.now();

                // Add error handling for failed favicon loads
                link.onerror = () => {
                    console.warn(`Failed to load favicon: ${cloak.icon}, falling back to default`);
                    const defaultLink = document.createElement('link');
                    defaultLink.rel = 'icon';
                    defaultLink.type = 'image/x-icon';
                    defaultLink.href = 'data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAP8A//8AAAD//wD/AAAAAP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/';
                    document.head.appendChild(defaultLink);
                };

                document.head.appendChild(link);
                StorageUtils.setObject('cloak', { title: cloak.title, icon: cloak.icon });
            } catch (error) {
                console.warn('Error setting favicon:', error);
                // Fallback to default favicon on any error
                const defaultLink = document.createElement('link');
                defaultLink.rel = 'icon';
                defaultLink.type = 'image/x-icon';
                defaultLink.href = 'data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAP8A//8AAAD//wD/AAAAAP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/';
                document.head.appendChild(defaultLink);
            }
        }
    }

    initializeCloakRotation() {
        const { cloakRotation, rotationInterval } = this.settings.privacy;

        if (!cloakRotation) {
            // rotation disabled; nothing to schedule
            return;
        }

        let currentCloakIndex = 0;
        let rotationTimeout;

        const rotateCloak = () => {
            try {
                const cloak = this.cloaks[currentCloakIndex];
                if (!cloak) return;

                this.applyCloak(cloak.name);
                currentCloakIndex = (currentCloakIndex + 1) % this.cloaks.length;

                // Store current index for persistence
                StorageUtils.set('currentCloakIndex', currentCloakIndex.toString());

            } catch (error) {
                console.warn('Error rotating cloak:', error);
            }
        };

        const startRotation = () => {
            const intervalMs = Math.max(500, Math.min(10000, rotationInterval * 1000));
            rotationTimeout = setTimeout(() => {
                rotateCloak();
                startRotation(); // Continue rotation
            }, intervalMs);
        };

        const stopRotation = () => {
            if (rotationTimeout) {
                clearTimeout(rotationTimeout);
                rotationTimeout = null;
            }
        };

        // Initialize with saved index
        const savedIndex = parseInt(StorageUtils.get('currentCloakIndex', '0'));
        currentCloakIndex = Math.min(savedIndex, this.cloaks.length - 1);

        // Start initial rotation
        startRotation();

    }

    applyAntiClose(enabled) {
        // Centralized: driven by unblockee_antiClose (set from Cloaks/Privacy)
        const targetWindow = window.inFrame ? window.top : window;
        const handler = (e) => {
            e.preventDefault();
            e.returnValue = 'Are you sure you want to leave?';
            return 'Are you sure you want to leave?';
        };

        try {
            targetWindow.removeEventListener('beforeunload', handler);
            if (enabled) {
                targetWindow.addEventListener('beforeunload', handler);
            }
        } catch (error) {
            console.warn('Failed to apply anti-close handler:', error);
        }
    }

    // Legacy auto-launch is deprecated in the new model; kept as a no-op for safety.
    handleAutoLaunch() {
        return;
    }

    // Helper methods for UI updates
    toggleRotationIntervalVisibility() {
        if (this.elements.rotationIntervalGroup) {
            this.elements.rotationIntervalGroup.style.display = this.elements.cloakRotation.checked ? 'block' : 'none';
        }
    }

    updateRotationIntervalDisplay() {
        if (this.elements.rotationIntervalValue) {
            this.elements.rotationIntervalValue.textContent = this.elements.rotationInterval.value + 's';
        }
    }

    toggleAboutBlankSubgroupVisibility() {
        if (this.elements.aboutBlankLaunching && this.modal) {
            const subgroup = this.modal.querySelector('#about-blank-subgroup');
            if (subgroup) {
                subgroup.style.display = this.elements.aboutBlankLaunching.checked ? 'block' : 'none';
            }
        }
    }

    isValidColor(color) {
        return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);
    }

    isLikelyImageUrl(url) {
        return /\.(jpe?g|png|gif|webp|bmp|svg)(\?.*)?$/i.test(url);
    }

    updateThemePreviewChips() {
        if (!this.elements.themePreview) return;
        const rootStyles = getComputedStyle(document.documentElement);
        const chips = this.elements.themePreview.querySelectorAll('.theme-preview-chip');
        chips.forEach(chip => {
            if (chip.classList.contains('primary')) {
                chip.style.backgroundColor = rootStyles.getPropertyValue('--primary-color') || '#a1a1a6';
            } else if (chip.classList.contains('secondary')) {
                chip.style.backgroundColor = rootStyles.getPropertyValue('--secondary-color') || '#ffffff';
            } else if (chip.classList.contains('bg')) {
                chip.style.backgroundColor = rootStyles.getPropertyValue('--background-color') || '#0d0d0d';
            } else if (chip.classList.contains('text')) {
                chip.style.backgroundColor = rootStyles.getPropertyValue('--text-color') || '#ffffff';
            }
        });
    }

    renderCloakList() {
        if (!this.elements.cloakList) return;

        const saved = (window.StorageUtils && StorageUtils.getObject)
            ? StorageUtils.getObject('cloak', {})
            : {};

        this.elements.cloakList.innerHTML = this.cloaks.map(cloak => {
            const selected = saved && saved.title === cloak.title && saved.icon === cloak.icon;
            const isRotating = window.CloakRotationManager?.getStatus().isRotating;
            return `
                <div class="cloak-item ${selected ? 'cloak-item-selected' : ''} ${isRotating ? 'cloak-item-disabled' : ''}" data-cloak-name="${cloak.name}">
                    <div class="cloak-item-icon">
                        <img src="${cloak.icon}" alt="${cloak.name}">
                    </div>
                    <div class="cloak-item-labels">
                        <div class="cloak-item-name">${cloak.name}</div>
                        <div class="cloak-item-title">${cloak.title}</div>
                    </div>
                </div>
            `;
        }).join('');

        this.elements.cloakList.querySelectorAll('.cloak-item').forEach(item => {
            item.addEventListener('click', () => {
                const name = item.getAttribute('data-cloak-name');
                if (!name) return;

                // Prevent manual selection when rotation is active
                if (window.CloakRotationManager?.getStatus().isRotating) {
                    if (window.notify) {
                        window.notify('Cannot manually select cloak while rotation is active. Stop rotation first.', 'warn');
                    } else {
                        alert('Cannot manually select cloak while rotation is active. Stop rotation first.');
                    }
                    return;
                }

                this.elements.cloakList
                    .querySelectorAll('.cloak-item')
                    .forEach(el => el.classList.remove('cloak-item-selected'));
                item.classList.add('cloak-item-selected');
                this.applyCloak(name);
            });
        });
    }

    /**
     * Initialize cloak rotation UI components
     */
    initializeCloakRotationUI() {
        if (!window.CloakRotationManager) return;

        const manager = window.CloakRotationManager;
        const status = manager.getStatus();

        // Set initial toggle state
        if (this.elements.cloakRotationToggle) {
            this.elements.cloakRotationToggle.checked = status.rotationEnabled;
            this.elements.cloakRotationToggle.addEventListener('change', (e) => {
                manager.setRotationEnabled(e.target.checked);
            });
        }

        // Set initial interval
        if (this.elements.cloakRotationInterval) {
            this.elements.cloakRotationInterval.value = status.rotationInterval;
            this.updateRotationIntervalDisplay();

            this.elements.cloakRotationInterval.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                manager.setRotationInterval(value);
                this.updateRotationIntervalDisplay();
            });
        }

        // Show/hide rotation settings based on toggle
        this.updateRotationSettingsVisibility();

        // Add custom cloak button
        if (this.elements.addCustomCloakBtn) {
            this.elements.addCustomCloakBtn.addEventListener('click', () => {
                this.addCustomCloak();
            });
        }

        // Enter key support for custom cloak inputs
        if (this.elements.customCloakTitle && this.elements.customCloakIcon) {
            [this.elements.customCloakTitle, this.elements.customCloakIcon].forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addCustomCloak();
                    }
                });
            });
        }

        // Render custom cloaks list
        this.renderCustomCloaksList();

        // Listen for rotation events
        this.setupCloakRotationEventListeners();
    }

    /**
     * Initialize cloak rotation toggle behavior to show/hide slider immediately
     */
    initializeCloakRotationToggleBehavior() {
        if (!this.elements.cloakRotationToggle) return;

        this.elements.cloakRotationToggle.addEventListener('change', (e) => {
            this.updateRotationSettingsVisibility();
        });
    }

    /**
     * Update rotation interval display
     */
    updateRotationIntervalDisplay() {
        if (this.elements.rotationIntervalValue && this.elements.cloakRotationInterval) {
            const value = this.elements.cloakRotationInterval.value;
            this.elements.rotationIntervalValue.textContent = `${value}s`;
        }
    }

    /**
     * Update rotation settings visibility
     */
    updateRotationSettingsVisibility() {
        if (this.elements.cloakRotationSettings && this.elements.cloakRotationToggle) {
            this.elements.cloakRotationSettings.style.display =
                this.elements.cloakRotationToggle.checked ? 'block' : 'none';
        }
    }

    /**
     * Add a custom cloak from the UI
     */
    addCustomCloak() {
        if (!window.CloakRotationManager) return;

        const title = this.elements.customCloakTitle?.value?.trim();
        const iconUrl = this.elements.customCloakIcon?.value?.trim();

        if (!title || !iconUrl) {
            if (window.notify) {
                window.notify('Please enter both title and icon URL', 'warn');
            } else {
                alert('Please enter both title and icon URL');
            }
            return;
        }

        try {
            const cloak = window.CloakRotationManager.addCustomCloak(title, iconUrl);
            this.renderCustomCloaksList();

            // Clear inputs
            if (this.elements.customCloakTitle) this.elements.customCloakTitle.value = '';
            if (this.elements.customCloakIcon) this.elements.customCloakIcon.value = '';

            if (window.notify) {
                window.notify('Custom cloak added successfully', 'success');
            }
        } catch (error) {
            if (window.notify) {
                window.notify(error.message, 'error');
            } else {
                alert(error.message);
            }
        }
    }

    /**
     * Render the custom cloaks list
     */
    renderCustomCloaksList() {
        if (!this.elements.customCloaksList || !window.CloakRotationManager) return;

        const customCloaks = window.CloakRotationManager.getCustomCloaks();

        if (customCloaks.length === 0) {
            this.elements.customCloaksList.innerHTML = '<div class="no-custom-cloaks">No custom cloaks added yet</div>';
            return;
        }

        this.elements.customCloaksList.innerHTML = customCloaks.map((cloak, index) => `
            <div class="custom-cloak-item" data-index="${index}">
                <div class="custom-cloak-info">
                    <div class="custom-cloak-title">${cloak.title}</div>
                    <div class="custom-cloak-icon-url">${cloak.icon}</div>
                </div>
                <button type="button" class="btn-remove-custom-cloak" onclick="settingsModal.removeCustomCloak(${index})">
                    🗑️
                </button>
            </div>
        `).join('');
    }

    /**
     * Remove a custom cloak
     * @param {number} index
     */
    removeCustomCloak(index) {
        if (!window.CloakRotationManager) return;

        if (!confirm('Remove this custom cloak?')) return;

        try {
            window.CloakRotationManager.removeCustomCloak(index);
            this.renderCustomCloaksList();

            if (window.notify) {
                window.notify('Custom cloak removed', 'success');
            }
        } catch (error) {
            if (window.notify) {
                window.notify(error.message, 'error');
            } else {
                alert(error.message);
            }
        }
    }

    /**
     * Setup event listeners for cloak rotation events
     */
    setupCloakRotationEventListeners() {
        // Listen for rotation status changes
        document.addEventListener('cloakRotationEnabledChanged', (e) => {
            if (this.elements.cloakRotationToggle) {
                this.elements.cloakRotationToggle.checked = e.detail.enabled;
            }
            this.updateRotationSettingsVisibility();
            this.updateRotationIndicator();
            this.renderCloakList(); // Update cloak list disabled state
        });

        document.addEventListener('cloakRotationIntervalChanged', (e) => {
            if (this.elements.cloakRotationInterval) {
                this.elements.cloakRotationInterval.value = e.detail.interval;
                this.updateRotationIntervalDisplay();
            }
        });

        document.addEventListener('cloakRotationStarted', () => {
            this.updateRotationIndicator();
            this.renderCloakList();
        });

        document.addEventListener('cloakRotationStopped', () => {
            this.updateRotationIndicator();
            this.renderCloakList();
        });

        document.addEventListener('customCloakAdded', () => {
            this.renderCustomCloaksList();
        });

        document.addEventListener('customCloakRemoved', () => {
            this.renderCustomCloaksList();
        });
    }

    /**
     * Update rotation indicator visibility
     */
    updateRotationIndicator() {
        if (!this.elements.cloakRotationIndicator || !window.CloakRotationManager) return;

        const isRotating = window.CloakRotationManager.getStatus().isRotating;
        this.elements.cloakRotationIndicator.style.display = isRotating ? 'inline' : 'none';
    }

    switchTab(tabName) {
        if (!this.elements || !this.elements.navItems || !this.elements.tabs) return;

        // Validate tab exists
        const validTabs = this.tabs.map(tab => tab.id);
        if (!validTabs.includes(tabName)) {
            console.warn(`Invalid tab name: ${tabName}, defaulting to general`);
            tabName = 'general';
        }

        // Update navigation (visual + ARIA)
        this.elements.navItems.forEach(item => {
            const isActive = item.dataset.tab === tabName;
            item.classList.toggle('active', isActive);
            item.setAttribute('aria-selected', isActive ? 'true' : 'false');
            item.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        // Update tab panels
        this.elements.tabs.forEach(tab => {
            const isActive = tab.dataset.tab === tabName;
            tab.classList.toggle('active', isActive);
            tab.setAttribute('aria-hidden', isActive ? 'false' : 'true');
        });

        this.currentTab = tabName;

        // Lazy-load offline games when Offline tab is shown
        if (tabName === 'offline') {
            this.loadOfflineGamesIntoList();
            this.loadCachedGamesIntoList();
        }
    }

    updateColorPreview(fieldId, color) {
        // Add color preview functionality
        const preview = document.querySelector(`#${fieldId}-preview`);
        if (preview) {
            preview.style.backgroundColor = color;
        }
    }

    /**
     * Debounced theme application to prevent excessive DOM manipulation.
     * Triggers a settings recompute + persistence shortly after user stops changing colors.
     */
    debounceThemeApplication() {
        if (this.themeApplicationDebounce) {
            clearTimeout(this.themeApplicationDebounce);
        }

        this.themeApplicationDebounce = setTimeout(() => {
            const snapshot = this.collectSettings();
            this.applyThemePreset(snapshot.themePreset, snapshot.customBackground);
            this.persistSettings(snapshot);
            this.themeApplicationDebounce = null;
        }, 150);
    }

    // Deprecated in favor of applyThemePreset; retained as no-op wrapper.
    applyThemeToApp() {
        return;
    }

    // Layout tuning removed from UI; keep no-op for compatibility.
    applyLayoutSettings() {
        return;
    }

    // Animation tuning removed from UI; keep no-op for compatibility.
    applyAnimationSettings() {
        return;
    }

    // Legacy helpers below are unused in the new simplified settings, but kept
    // as stubs where needed for backward compatibility with any external calls.
    getSelectedThemeName() {
        return 'Custom';
    }

    getSelectedBackgroundType() {
        const backgroundSelect = this.elements.backgroundSelect;
        if (!backgroundSelect) return 'color';

        const selectedValue = backgroundSelect.value;
        const background = this.backgrounds.find(b => b.name === selectedValue);
        return background ? background.type : 'color';
    }

    getSelectedBackgroundValue() {
        const backgroundSelect = this.elements.backgroundSelect;
        if (!backgroundSelect) return '#0d0d0d';

        const selectedValue = backgroundSelect.value;
        if (selectedValue === 'Custom') {
            const customUrl = this.elements.customBackgroundUrl.value;
            return customUrl || '#0d0d0d';
        } else if (selectedValue === 'YouTube Video') {
            const youtubeUrl = this.elements.youtubeUrl.value;
            return youtubeUrl || '';
        } else if (selectedValue === 'Image URL') {
            const imageUrl = this.elements.imageUrl.value;
            return imageUrl || '';
        }

        const background = this.backgrounds.find(b => b.name === selectedValue);
        return background ? background.value : '#0d0d0d';
    }

    populateThemePresets() {
        // Presets already rendered via select; ensure a valid value.
        if (this.elements.themePresetSelect) {
            const value = this.elements.themePresetSelect.value || 'dark';
            if (!['dark', 'ocean', 'forest'].includes(value)) {
                this.elements.themePresetSelect.value = 'dark';
            }
        }
    }

    populateBackgroundOptions() {
        // No-op: background handled via custom background controls.
    }

    selectThemePreset(theme) {
        // Update form values
        this.elements.primaryColor.value = theme.primaryColor;
        this.elements.primaryColorText.value = theme.primaryColor;
        this.elements.secondaryColor.value = theme.secondaryColor;
        this.elements.secondaryColorText.value = theme.secondaryColor;
        this.elements.bgColor.value = theme.bgColor;
        this.elements.bgColorText.value = theme.bgColor;
        this.elements.cardColor.value = theme.cardColor;
        this.elements.cardColorText.value = theme.cardColor;
        this.elements.textColor.value = theme.textColor;
        this.elements.textColorText.value = theme.textColor;

        // Update settings
        this.settings.themeName = theme.name;
        this.settings.primaryColor = theme.primaryColor;
        this.settings.secondaryColor = theme.secondaryColor;
        this.settings.colors.bgColor = theme.bgColor;
        this.settings.colors.cardColor = theme.cardColor;
        this.settings.colors.textColor = theme.textColor;

        // Apply theme immediately
        this.applyThemeToApp(this.settings);

        // Highlight selected preset
        const presetItems = this.elements.themePresetGrid.querySelectorAll('.theme-preset-item');
        presetItems.forEach(item => item.classList.remove('selected'));
        const selectedItem = this.elements.themePresetGrid.querySelector(`[data-theme="${theme.name}"]`);
        if (selectedItem) selectedItem.classList.add('selected');
    }

    updateCustomBackgroundVisibility() {
        const backgroundSelect = this.elements.backgroundSelect;
        const customGroup = this.elements.customBackgroundGroup;

        if (backgroundSelect && customGroup) {
            customGroup.style.display = backgroundSelect.value === 'Custom' ? 'block' : 'none';
        }
    }

    updateYouTubeUrlVisibility() {
        const backgroundSelect = this.elements.backgroundSelect;
        const youtubeGroup = this.elements.youtubeUrlGroup;

        if (backgroundSelect && youtubeGroup) {
            youtubeGroup.style.display = backgroundSelect.value === 'YouTube Video' ? 'block' : 'none';
        }
    }

    updateImageUrlVisibility() {
        const backgroundSelect = this.elements.backgroundSelect;
        const imageGroup = this.elements.imageUrlGroup;

        if (backgroundSelect && imageGroup) {
            imageGroup.style.display = backgroundSelect.value === 'Image URL' ? 'block' : 'none';
        }
    }

    updateBackgroundPreviewVisibility() {
        const backgroundSelect = this.elements.backgroundSelect;
        const previewGroup = this.elements.backgroundPreviewGroup;

        if (backgroundSelect && previewGroup) {
            const selectedValue = backgroundSelect.value;
            const showPreview = selectedValue === 'YouTube Video' || selectedValue === 'Image URL' || selectedValue === 'Custom';
            previewGroup.style.display = showPreview ? 'block' : 'none';
        }
    }

    validateYouTubeUrl() {
        const url = this.elements.youtubeUrl.value;
        if (!url) return;

        const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)/;
        this.setFieldValidity(this.elements.youtubeUrl, youtubeRegex.test(url));
    }

    validateImageUrl() {
        const url = this.elements.imageUrl.value;
        if (!url) return;

        const imageRegex = /\.(jpeg|jpg|gif|png|webp|bmp|svg)(\?.*)?$/i;
        this.setFieldValidity(this.elements.imageUrl, imageRegex.test(url));
    }

    updateBackgroundPreview() {
        const preview = this.elements.backgroundPreview;
        if (!preview) return;

        const selectedValue = this.elements.backgroundSelect.value;
        let previewContent = '';

        if (selectedValue === 'YouTube Video') {
            const url = this.elements.youtubeUrl.value;
            if (url) {
                const videoId = this.extractYouTubeVideoId(url);
                if (videoId) {
                    previewContent = `<iframe width="300" height="200" src="https://www.youtube.com/embed/${videoId}?autoplay=0&mute=1" frameborder="0" allowfullscreen></iframe>`;
                } else {
                    previewContent = '<div class="preview-error">Invalid YouTube URL</div>';
                }
            } else {
                previewContent = '<div class="preview-placeholder">Enter a YouTube URL to see preview</div>';
            }
        } else if (selectedValue === 'Image URL') {
            const url = this.elements.imageUrl.value;
            if (url) {
                previewContent = `<img src="${url}" alt="Background preview" style="max-width: 300px; max-height: 200px; object-fit: cover;">`;
            } else {
                previewContent = '<div class="preview-placeholder">Enter an image URL to see preview</div>';
            }
        } else if (selectedValue === 'Custom') {
            const url = this.elements.customBackgroundUrl.value;
            if (url) {
                if (url.includes('youtube.com') || url.includes('youtu.be')) {
                    const videoId = this.extractYouTubeVideoId(url);
                    if (videoId) {
                        previewContent = `<iframe width="300" height="200" src="https://www.youtube.com/embed/${videoId}?autoplay=0&mute=1" frameborder="0" allowfullscreen></iframe>`;
                    } else {
                        previewContent = '<div class="preview-error">Invalid YouTube URL</div>';
                    }
                } else {
                    previewContent = `<img src="${url}" alt="Background preview" style="max-width: 300px; max-height: 200px; object-fit: cover;">`;
                }
            } else {
                previewContent = '<div class="preview-placeholder">Enter a URL to see preview</div>';
            }
        } else {
            previewContent = '<div class="preview-placeholder">Select a background to see preview</div>';
        }

        preview.innerHTML = previewContent;
    }

    extractYouTubeVideoId(url) {
        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[2].length == 11) ? match[2] : null;
    }

    updateBackgroundColorVisibility() {
        const backgroundSelect = this.elements.backgroundSelect;
        const backgroundColorGroup = this.elements.backgroundColorGroup;

        if (backgroundSelect && backgroundColorGroup) {
            const selectedValue = backgroundSelect.value;
            const background = this.backgrounds.find(b => b.name === selectedValue);
            const isColorBackground = selectedValue === 'Custom' || (background && background.type === 'color');

            backgroundColorGroup.style.display = isColorBackground ? 'block' : 'none';
        }
    }

    testFavicon() {
        const url = this.elements.faviconUrl.value;
        if (!url || !this.isValidUrl(url)) {
            alert('Please enter a valid favicon URL');
            return;
        }

        const link = document.createElement('link');
        link.rel = 'icon';
        link.href = url;
        link.onload = () => alert('Favicon loaded successfully!');
        link.onerror = () => alert('Failed to load favicon');
        document.head.appendChild(link);
    }


    testGemini() {
        const apiKey = this.elements.geminiApiKey.value;
        if (!apiKey) {
            alert('Please enter a Gemini API key');
            return;
        }

        if (!apiKey.startsWith('AIza')) {
            alert('Please enter a valid Gemini API key (starts with AIza)');
            return;
        }

        this.elements.testGemini.textContent = 'Testing...';
        this.elements.testGemini.disabled = true;

        fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: 'Hello' }]
                }],
                generationConfig: {
                    maxOutputTokens: 10
                }
            })
        })
        .then(response => {
            if (response.ok) {
                alert('Gemini API key is valid!');
            } else {
                throw new Error('Invalid API key');
            }
        })
        .catch(error => {
            alert('Gemini API test failed: ' + error.message);
        })
        .finally(() => {
            this.elements.testGemini.textContent = 'Test';
            this.elements.testGemini.disabled = false;
        });
    }

    testOpenAI() {
        const apiKey = this.elements.openaiApiKey.value;
        if (!apiKey) {
            alert('Please enter an OpenAI API key');
            return;
        }

        if (!apiKey.startsWith('sk-')) {
            alert('Please enter a valid OpenAI API key (starts with sk-)');
            return;
        }

        this.elements.testOpenai.textContent = 'Testing...';
        this.elements.testOpenai.disabled = true;

        fetch('https://api.openai.com/v1/models', {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.data && data.data.length > 0) {
                alert('OpenAI API key is valid!');
            } else {
                throw new Error('Invalid API key');
            }
        })
        .catch(error => {
            alert('OpenAI API test failed: ' + error.message);
        })
        .finally(() => {
            this.elements.testOpenai.textContent = 'Test';
            this.elements.testOpenai.disabled = false;
        });
    }

    setPanicKey() {
        const input = this.elements.panicKey;
        input.value = 'Press a key...';
        input.classList.add('recording');

        const keyHandler = (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const key = e.key === ' ' ? 'Space' : e.key;
            if (['Control', 'Alt', 'Shift', 'Meta'].includes(key)) {
                alert('Please use a non-modifier key.');
                return;
            }

            input.value = key;
            input.classList.remove('recording');
            document.removeEventListener('keydown', keyHandler, true);
        };

        document.addEventListener('keydown', keyHandler, true);
    }


    importSettings() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const settings = JSON.parse(e.target.result);
                    this.applySettings(settings);
                    alert('Settings imported successfully!');
                } catch (error) {
                    alert('Failed to import settings: Invalid JSON');
                }
            };
            reader.readAsText(file);
        };

        input.click();
    }

    exportSettings() {
        const settings = this.collectSettings();
        const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'unblockee-settings.json';
        a.click();
        
        URL.revokeObjectURL(url);
    }

    resetSettings() {
        if (confirm('Reset all settings to defaults?')) {
            // Clear known StorageUtils keys
            StorageUtils.remove('settings');
            StorageUtils.remove('selectedCloak');
            StorageUtils.remove('panicKey');
            StorageUtils.remove('panicAction');
            StorageUtils.remove('antiClose');
            StorageUtils.remove('aboutBlankLaunching');
            StorageUtils.remove('autoAboutBlankLaunch');
            StorageUtils.remove('autoBlobTabLaunch');
            StorageUtils.remove('offlineMode');
            StorageUtils.remove('theme');
            StorageUtils.remove('selectedTheme');
            StorageUtils.remove('cloak');
            StorageUtils.remove('currentCloakIndex');
            StorageUtils.remove('autoLaunchExecuted');
            StorageUtils.remove('proxServer');
            this.settings = this.getDefaultSettings();
            this.populateForm();
            alert('Settings reset to defaults');
        }
    }

    clearCache() {
        if (confirm('Clear all cached data?')) {
            // Use service worker to clear cache if available
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'CLEAR_CACHE'
                });
                
                // Listen for response
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => {
                    if (event.data.success) {
                        StorageUtils.remove('gamePlayCount');
                        StorageUtils.remove('cachedGames');
                        this.updateCachedGamesList();
                        alert('Cache cleared successfully');
                    }
                };
                
                navigator.serviceWorker.controller.postMessage({
                    type: 'CLEAR_CACHE'
                }, [messageChannel.port2]);
            } else {
                // Fallback to manual cache clearing
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => {
                            caches.delete(name);
                        });
                    });
                }
                
                // Clear all StorageUtils keys - since we can't clear all localStorage, we'll need to be selective
                // For now, clear specific known keys
                StorageUtils.remove('gamePlayCount');
                StorageUtils.remove('cachedGames');
                StorageUtils.remove('settings');
                StorageUtils.remove('cloak');
                StorageUtils.remove('currentCloakIndex');
                StorageUtils.remove('autoLaunchExecuted');
                // Add more keys as needed
                this.elements.cachedGamesList.innerHTML = '<div class="no-games">Cache cleared</div>';
                alert('Cache cleared successfully');
            }
        }
    }

    // Update cached games list in settings
    updateCachedGamesList() {
        this.loadCachedGames();
    }

    // Load cached games from service worker
    async loadCachedGames() {
        try {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => {
                    this.renderCachedGames(event.data);
                };
                
                navigator.serviceWorker.controller.postMessage({
                    type: 'GET_CACHE_STATUS'
                }, [messageChannel.port2]);
            } else {
                // Fallback: load from localStorage
                const cachedGames = StorageUtils.getObject('cachedGames', []);
                this.renderCachedGames({
                    cachedGamesCount: cachedGames.length,
                    topGames: [],
                    recentGames: cachedGames.slice(-5).reverse()
                });
            }
        } catch (error) {
            console.warn('Failed to load cached games:', error);
            this.elements.cachedGamesList.innerHTML = '<div class="no-games">Failed to load cached games</div>';
        }
    }

    // Load cached games into the split-view list
    loadCachedGamesIntoList() {
        if (!this.elements.cachedGamesList) return;

        try {
            // Load from service worker cache status
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => {
                    this.renderCachedGamesList(event.data);
                };

                navigator.serviceWorker.controller.postMessage({
                    type: 'GET_CACHE_STATUS'
                }, [messageChannel.port2]);
            } else {
                // Fallback to localStorage
                const cachedGames = StorageUtils.getObject('cachedGames', []);
                this.renderCachedGamesList({
                    cachedGamesCount: cachedGames.length,
                    cacheSize: 0, // Can't calculate without service worker
                    recentGames: cachedGames.slice(-10).reverse()
                });
            }
        } catch (error) {
            console.warn('Failed to load cached games list:', error);
            this.elements.cachedGamesList.innerHTML = '<div class="no-games">Failed to load cached games</div>';
        }
    }

    // Render cached games in the split-view layout
    renderCachedGamesList(cacheData) {
        const container = this.elements.cachedGamesList;

        // Update statistics
        if (this.elements.cacheGamesCount) {
            this.elements.cacheGamesCount.textContent = cacheData.cachedGamesCount || 0;
        }
        if (this.elements.cacheTotalSize) {
            this.elements.cacheTotalSize.textContent = this.formatBytes(cacheData.cacheSize || 0);
        }

        if (!cacheData.cachedGamesCount || cacheData.cachedGamesCount === 0) {
            container.innerHTML = '<div class="no-games">No cached games</div>';
            return;
        }

        const gamesHtml = cacheData.recentGames.map(game => `
            <div class="cached-game-card" data-game-id="${game.id}">
                <div class="game-card-thumbnail">
                    <img src="${game.cover || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkdhbWU8L3RleHQ+PC9zdmc+'}"
                         alt="${game.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkdhbWU8L3RleHQ+PC9zdmc+'">
                </div>
                <div class="game-card-info">
                    <div class="game-card-name">${game.name || 'Unknown Game'}</div>
                    <div class="game-card-size">${this.formatBytes(game.size || 0)}</div>
                </div>
                <button type="button" class="btn-remove-game" title="Remove from cache">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M18 6 6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
        `).join('');

        container.innerHTML = gamesHtml;
    }

    // Remove a specific cached game
    async removeCachedGame(gameId) {
        if (!confirm('Remove this game from cache?')) return;
        
        try {
            // Update localStorage
            const cachedGames = StorageUtils.getObject('cachedGames', []);
            const filtered = cachedGames.filter(game => game.id !== gameId);
            StorageUtils.setObject('cachedGames', filtered);
            
            // Refresh the cached games list
            this.loadCachedGames();
            
            alert('Game removed from cache');
        } catch (error) {
            console.error('Failed to remove cached game:', error);
            alert('Failed to remove game from cache');
        }
    }

    // Format bytes to human readable format
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Format timestamp to readable date
    formatDate(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return 'Today';
        if (diffDays === 2) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays - 1} days ago`;
        return date.toLocaleDateString();
    }

    // Listen for service worker messages
    setupServiceWorkerListener() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'GAME_CACHED') {
                    this.loadCachedGames();
                }
            });
        }
    }

    // Game selection methods
    async openGameSelectionModal() {
        try {
            // Load zones.json data
            const response = await fetch('components/zones.json');
            const games = await response.json();
            
            // Filter out non-game entries (like Discord link)
            const actualGames = games.filter(game => game.id >= 0);
            
            // Get currently selected games
            const selectedGames = StorageUtils.getObject('selectedGamesForOffline', []);
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'game-selection-modal';
            modal.innerHTML = `
                <div class="game-selection-content">
                    <div class="game-selection-header">
                        <h3>Select Games for Offline Mode</h3>
                        <p>Choose up to 30 games to cache for offline play</p>
                        <div class="selection-count">
                            <span id="modal-selected-count">${selectedGames.length}</span> / 30 selected
                        </div>
                        <button type="button" class="close-modal" id="close-game-modal">✕</button>
                    </div>
                    <div class="game-selection-filters">
                        <input type="text" id="modal-game-search" placeholder="Search games...">
                        <select id="modal-game-filter">
                            <option value="all">All Games</option>
                            <option value="featured">Featured</option>
                            <option value="flash">Flash Games</option>
                            <option value="port">Ports</option>
                            <option value="emulator">Emulators</option>
                        </select>
                    </div>
                    <div class="games-grid" id="games-grid">
                        ${this.renderGamesGrid(actualGames, selectedGames)}
                    </div>
                    <div class="game-selection-footer">
                        <button type="button" id="save-game-selection" class="btn btn-primary">Save Selection</button>
                        <button type="button" id="cancel-game-selection" class="btn btn-secondary">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Bind events
            this.bindGameSelectionEvents(modal, actualGames, selectedGames);
            
        } catch (error) {
            console.error('Failed to open game selection modal:', error);
            alert('Failed to load games. Please try again.');
        }
    }
    
    renderGamesGrid(games, selectedGames) {
        const selectedIds = selectedGames.map(g => g.id);
        
        return games.map(game => {
            const isSelected = selectedIds.includes(game.id);
            const hasSpecial = game.special && game.special.length > 0;
            const isFeatured = game.featured;
            
            return `
                <div class="game-item ${isSelected ? 'selected' : ''}" data-game-id="${game.id}">
                    <div class="game-cover">
                        <img src="${game.cover}" alt="${game.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkdhbWU8L3RleHQ+PC9zdmc+'">
                        ${isFeatured ? '<div class="featured-badge">⭐</div>' : ''}
                        ${hasSpecial ? `<div class="special-badge">${game.special[0]}</div>` : ''}
                    </div>
                    <div class="game-info">
                        <h4 class="game-name">${game.name}</h4>
                        <p class="game-author">${game.author || 'Unknown'}</p>
                    </div>
                    <div class="game-select-checkbox">
                        <input type="checkbox" ${isSelected ? 'checked' : ''}>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    bindGameSelectionEvents(modal, games, selectedGames) {
        const closeBtn = modal.querySelector('#close-game-modal');
        const cancelBtn = modal.querySelector('#cancel-game-selection');
        const saveBtn = modal.querySelector('#save-game-selection');
        const searchInput = modal.querySelector('#modal-game-search');
        const filterSelect = modal.querySelector('#modal-game-filter');
        const gamesGrid = modal.querySelector('#games-grid');
        const selectedCount = modal.querySelector('#modal-selected-count');
        
        // Close events
        closeBtn?.addEventListener('click', () => modal.remove());
        cancelBtn?.addEventListener('click', () => modal.remove());
        
        // Filter events
        searchInput?.addEventListener('input', () => this.filterModalGames(modal, games, selectedGames));
        filterSelect?.addEventListener('change', () => this.filterModalGames(modal, games, selectedGames));
        
        // Game selection events
        gamesGrid?.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                const gameItem = e.target.closest('.game-item');
                const gameId = parseInt(gameItem.dataset.gameId);
                
                if (e.target.checked) {
                    if (selectedGames.length >= 30) {
                        e.target.checked = false;
                        alert('You can only select up to 30 games for offline mode.');
                        return;
                    }
                    selectedGames.push(games.find(g => g.id === gameId));
                } else {
                    const index = selectedGames.findIndex(g => g.id === gameId);
                    if (index > -1) selectedGames.splice(index, 1);
                }
                
                gameItem.classList.toggle('selected', e.target.checked);
                selectedCount.textContent = selectedGames.length;
            }
        });
        
        // Save selection
        saveBtn?.addEventListener('click', () => {
            StorageUtils.setObject('selectedGamesForOffline', selectedGames);
            this.updateSelectedGamesCount();
            modal.remove();
            alert(`Selected ${selectedGames.length} games for offline caching.`);
        });
    }
    
    filterModalGames(modal, games, selectedGames) {
        const searchTerm = modal.querySelector('#modal-game-search').value.toLowerCase();
        const filter = modal.querySelector('#modal-game-filter').value;
        
        let filteredGames = games.filter(game => {
            // Search filter
            if (searchTerm && !game.name.toLowerCase().includes(searchTerm)) {
                return false;
            }
            
            // Category filter
            switch (filter) {
                case 'featured':
                    return game.featured;
                case 'flash':
                    return game.special && game.special.includes('flash');
                case 'port':
                    return game.special && game.special.includes('port');
                case 'emulator':
                    return game.special && game.special.includes('emulator');
                default:
                    return true;
            }
        });
        
        const gamesGrid = modal.querySelector('#games-grid');
        gamesGrid.innerHTML = this.renderGamesGrid(filteredGames, selectedGames);
    }
    
    filterGames() {
        // Update the display of selected games count
        this.updateSelectedGamesCount();
    }
    
    updateSelectedGamesCount() {
        const selectedGames = StorageUtils.getObject('selectedGamesForOffline', []);
        if (this.elements.selectedGamesCount) {
            this.elements.selectedGamesCount.textContent = selectedGames.length;
        }
    }
    
    async cacheSelectedGames() {
        const selectedGames = StorageUtils.getObject('selectedGamesForOffline', []);
        
        if (selectedGames.length === 0) {
            alert('No games selected for caching. Please select games first.');
            return;
        }
        
        if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
            alert('Service worker not available. Please refresh the page and try again.');
            return;
        }
        
        const confirmed = confirm(`Cache ${selectedGames.length} games for offline play? This may take a few minutes.`);
        if (!confirmed) return;
        
        // Send cache request to service worker
        navigator.serviceWorker.controller.postMessage({
            type: 'CACHE_GAMES',
            games: selectedGames
        });
        
        // Show loading indicator
        if (this.elements.cacheSelectedGames) {
            this.elements.cacheSelectedGames.textContent = 'Caching...';
            this.elements.cacheSelectedGames.disabled = true;
        }
        
        // Listen for completion
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
            if (event.data.type === 'CACHE_COMPLETE') {
                if (this.elements.cacheSelectedGames) {
                    this.elements.cacheSelectedGames.textContent = 'Cache Selected Games';
                    this.elements.cacheSelectedGames.disabled = false;
                }
                this.loadCachedGames();
                alert(`Successfully cached ${event.data.cachedCount} games for offline play.`);
            } else if (event.data.type === 'CACHE_ERROR') {
                if (this.elements.cacheSelectedGames) {
                    this.elements.cacheSelectedGames.textContent = 'Cache Selected Games';
                    this.elements.cacheSelectedGames.disabled = false;
                }
                alert('Error caching games: ' + event.data.error);
            }
        };
        
        navigator.serviceWorker.controller.postMessage({
            type: 'CACHE_GAMES',
            games: selectedGames
        }, [messageChannel.port2]);
    }

    loadSettings() {
        // Legacy aggregator retained only for migration-related helpers; core config is per-key now.
        const defaults = this.getDefaultSettings();
        try {
            return {
                ...defaults,
                ...(window.StorageUtils ? StorageUtils.getObject('settings', {}) : {})
            };
        } catch (error) {
            console.warn('Failed to load settings:', error);
            return defaults;
        }
    }

    getDefaultSettings() {
        // Defaults only used as a convenience; persisted state is per-key.
        return {
            themePreset: 'dark',
            customBackground: { type: 'hex-grid' }, // hex grid as default
            cloakMode: 'none',
            antiClose: false,
            panicKeys: 'none',
            primaryLibrary: 'default',
            altLibraryFile: '',
            offlineMode: true,
            offlineGames: [],
            maxRating: 'R',
            moviesProxyEnabled: false
        };
    }

    collectSettings() {
        // Read current UI state into the new unified keys.
        const themePreset = this.elements.themePresetSelect
            ? this.elements.themePresetSelect.value
            : 'dark';

        let customBgConfig = null;
        // Collect from preset dropdown first (authoritative)
        if (this.elements.backgroundPresetSelect) {
            switch (this.elements.backgroundPresetSelect.value) {
                case 'night-city':
                    customBgConfig = { type: 'image', url: 'https://images.pexels.com/photos/2837009/pexels-photo-2837009.jpeg?auto=compress&cs=tinysrgb&w=1600' };
                    break;
                case 'neon-grid':
                    customBgConfig = { type: 'image', url: 'https://images.pexels.com/photos/1322185/pexels-photo-1322185.jpeg?auto=compress&cs=tinysrgb&w=1600' };
                    break;
                case 'racing-f1':
                    customBgConfig = { type: 'youtube', videoId: '2x5bT-k64hA' };
                    break;
                case 'racing-rally':
                    customBgConfig = { type: 'youtube', videoId: 'dR2vR8VnXj0' };
                    break;
                case 'racing-motogp':
                    customBgConfig = { type: 'youtube', videoId: 'z4zE8ApsW6s' };
                    break;
                default:
                    customBgConfig = null;
            }
        }

        // If no preset selected, fall back to explicit custom mode/url
        if (!customBgConfig && this.elements.customBgUrl && this.elements.customBgModeRadios) {
            const url = this.elements.customBgUrl.value.trim();
            let mode = 'none';
            this.elements.customBgModeRadios.forEach(r => {
                if (r.checked) mode = r.value;
            });

            if (mode !== 'none' && url) {
                if (mode === 'youtube') {
                    const videoId = this.extractYouTubeVideoId(url);
                    if (videoId) {
                        customBgConfig = { type: 'youtube', videoId };
                    }
                } else if (mode === 'image' && this.isLikelyImageUrl(url)) {
                    customBgConfig = { type: 'image', url };
                }
            }
        }

        let cloakMode = 'none';
        if (this.elements.cloakModeSelect && this.elements.cloakModeSelect.value) {
            cloakMode = this.elements.cloakModeSelect.value;
        }

        // Enforce mutual exclusivity semantics defensively:
        // 'none' = no cloaking, 'about:blank' = about:blank cloaking, 'blob' = blob cloaking.
        if (!['none', 'about:blank', 'blob'].includes(cloakMode)) {
            cloakMode = 'none';
        }

        const antiClose =
            (this.elements.antiCloseToggle && this.elements.antiCloseToggle.checked) ||
            (this.elements.privacyAntiClose && this.elements.privacyAntiClose.checked);

        const panicKeys = this.elements.panicKeysSelect
            ? this.elements.panicKeysSelect.value
            : 'none';

        const primaryLibrary = this.elements.primaryLibrarySelect
            ? this.elements.primaryLibrarySelect.value || 'default'
            : 'default';

        const altLibraryFile = this.elements.altLibrarySelect
            ? this.elements.altLibrarySelect.value || ''
            : '';

        const offlineMode = this.elements.offlineModeToggle
            ? !!this.elements.offlineModeToggle.checked
            : true;

        // Global Color Thief setting
        const globalColorThief = this.elements.globalColorThiefToggle
            ? !!this.elements.globalColorThiefToggle.checked
            : false;

        // Movies settings
        const maxRating = this.elements.maxRatingSelect
            ? this.elements.maxRatingSelect.value
            : 'R';
        const moviesProxyEnabled = this.elements.moviesProxyEnabledToggle
            ? !!this.elements.moviesProxyEnabledToggle.checked
            : false;

        // Custom panic key settings
        let customPanicKey = null;
        let customPanicUrl = null;
        if (panicKeys === 'custom') {
            customPanicKey = this.elements.customPanicKey?.value?.trim() || null;
            customPanicUrl = this.elements.customPanicUrl?.value?.trim() || null;
        }

        // Offline selected games list (ids) from checkboxes in offlineGamesList
        const offlineGames = [];
        if (this.elements.offlineGamesList) {
            const checkboxes = this.elements.offlineGamesList.querySelectorAll(
                'input[type="checkbox"][data-game-id]:checked'
            );
            checkboxes.forEach(cb => {
                offlineGames.push(cb.getAttribute('data-game-id'));
            });
        }

        return {
            themePreset,
            customBackground: customBgConfig,
            cloakMode,
            antiClose,
            panicKeys,
            customPanicKey,
            customPanicUrl,
            primaryLibrary,
            altLibraryFile,
            offlineMode,
            offlineGames,
            globalColorThief,
            widgetbotEnabled,
            maxRating,
            moviesProxyEnabled
        };
    }

    applySettings(settings) {
        this.settings = { ...this.getDefaultSettings(), ...settings };
        this.populateForm();
    }

    populateForm() {
        const s = this.settings || this.getDefaultSettings();

        // General
        if (this.elements.primaryLibrarySelect) {
            this.elements.primaryLibrarySelect.value = s.primaryLibrary || 'default';
        }

        if (this.elements.altLibrarySelect) {
            this.elements.altLibrarySelect.value = s.altLibraryFile || '';
        }

        if (this.elements.offlineModeToggle) {
            // Default ON if missing
            this.elements.offlineModeToggle.checked = s.offlineMode !== false;
        }

        if (this.elements.offlineSelectedCount && Array.isArray(s.offlineGames)) {
            this.elements.offlineSelectedCount.textContent = Math.min(
                s.offlineGames.length,
                30
            );
        }

        // Appearance
        if (this.elements.themePresetSelect) {
            const preset = s.themePreset || 'dark';
            this.elements.themePresetSelect.value = ['dark', 'ocean', 'forest', 'custom'].includes(preset)
                ? preset
                : 'dark';
        }

        // Global Color Thief
        if (this.elements.globalColorThiefToggle) {
            this.elements.globalColorThiefToggle.checked = !!s.globalColorThief;
        }

        // WidgetBot
        if (this.elements.widgetbotEnabledToggle) {
            this.elements.widgetbotEnabledToggle.checked = s.widgetbotEnabled !== false;
        }

        // Movies settings
        if (this.elements.maxRatingSelect) {
            this.elements.maxRatingSelect.value = s.maxRating || 'R';
        }
        if (this.elements.moviesProxyEnabledToggle) {
            this.elements.moviesProxyEnabledToggle.checked = !!s.moviesProxyEnabled;
        }

        // Restore background preset + custom fields from customBackground
        if (s.customBackground) {
            const cb = s.customBackground;
            if (this.elements.backgroundPresetSelect) {
                if (cb.type === 'image') {
                    if (cb.url && cb.url.includes('2837009')) {
                        this.elements.backgroundPresetSelect.value = 'night-city';
                    } else if (cb.url && cb.url.includes('1322185')) {
                        this.elements.backgroundPresetSelect.value = 'neon-grid';
                    } else {
                        this.elements.backgroundPresetSelect.value = 'none';
                    }
                } else if (cb.type === 'youtube') {
                    if (cb.videoId === '2x5bT-k64hA') {
                        this.elements.backgroundPresetSelect.value = 'racing-f1';
                    } else if (cb.videoId === 'dR2vR8VnXj0') {
                        this.elements.backgroundPresetSelect.value = 'racing-rally';
                    } else if (cb.videoId === 'z4zE8ApsW6s') {
                        this.elements.backgroundPresetSelect.value = 'racing-motogp';
                    } else {
                        this.elements.backgroundPresetSelect.value = 'none';
                    }
                } else {
                    this.elements.backgroundPresetSelect.value = 'none';
                }
            }

            if (this.elements.customBgUrl) {
                if (cb.type === 'image' && cb.url) {
                    this.elements.customBgUrl.value = cb.url;
                } else if (cb.type === 'youtube' && cb.videoId) {
                    this.elements.customBgUrl.value = `https://www.youtube.com/watch?v=${cb.videoId}`;
                }
            }

            if (this.elements.customBgModeRadios) {
                const mode = cb.type || 'none';
                this.elements.customBgModeRadios.forEach(r => {
                    r.checked = r.value === mode;
                });
            }
        } else {
            if (this.elements.backgroundPresetSelect) {
                this.elements.backgroundPresetSelect.value = 'dark-grid';
            }
            if (this.elements.customBgUrl) {
                this.elements.customBgUrl.value = '';
            }
            if (this.elements.customBgModeRadios) {
                this.elements.customBgModeRadios.forEach(r => {
                    r.checked = r.value === 'none';
                });
            }
        }

        // Cloaks
        if (this.elements.cloakModeSelect) {
            const mode = ['none', 'about:blank', 'blob'].includes(s.cloakMode)
                ? s.cloakMode
                : 'none';
            this.elements.cloakModeSelect.value = mode;
        }

        if (this.elements.antiCloseToggle) {
            this.elements.antiCloseToggle.checked = !!s.antiClose;
        }

        if (this.elements.panicKeysSelect) {
            this.elements.panicKeysSelect.value = s.panicKeys || 'none';
        }

        // Custom panic key settings
        if (s.panicKeys === 'custom') {
            if (this.elements.customPanicSettings) {
                this.elements.customPanicSettings.style.display = 'block';
            }
            if (this.elements.customPanicKey && s.customPanicKey) {
                this.elements.customPanicKey.value = s.customPanicKey;
            }
            if (this.elements.customPanicUrl && s.customPanicUrl) {
                this.elements.customPanicUrl.value = s.customPanicUrl;
            }
        }

        // Privacy (mirror anti-close)
        if (this.elements.privacyAntiClose) {
            this.elements.privacyAntiClose.checked = !!s.antiClose;
        }
    }
    saveSettings() {
        const settings = this.collectSettings();

        // Basic defensive validation for critical values
        if (settings.customBackground && settings.customBackground.type === 'image') {
            try {
                // Throws if invalid; we only warn in console, not block save
                new URL(settings.customBackground.url);
            } catch {
                console.warn('Custom background image URL appears invalid, continuing without blocking save.');
            }
        }

        this.applySettings(settings);
        this.persistSettings(settings);
    }
    persistSettings(settings) {
        // New single-source-of-truth keys (no multiple booleans).
        try {
            // Persist unified theme preset including "custom"
            localStorage.setItem('unblockee_themePreset', settings.themePreset || 'dark');

            // Persist structured customBackground when present
            if (settings.customBackground) {
                localStorage.setItem(
                    'unblockee_customBackground',
                    JSON.stringify(settings.customBackground)
                );
            } else {
                localStorage.removeItem('unblockee_customBackground');
            }

            localStorage.setItem(
                'unblockee_cloakMode',
                settings.cloakMode || 'none'
            );

            localStorage.setItem(
                'unblockee_panicKeys',
                settings.panicKeys || 'none'
            );

            localStorage.setItem(
                'unblockee_primaryLibrary',
                settings.primaryLibrary || 'default'
            );

            localStorage.setItem(
                'unblockee_altLibraryFile',
                settings.altLibraryFile || ''
            );

            localStorage.setItem(
                'unblockee_offlineMode',
                settings.offlineMode ? 'true' : 'false'
            );

            // Enforce 30-game cap strictly
            const offlineGames = Array.isArray(settings.offlineGames)
                ? settings.offlineGames.slice(0, 30)
                : [];
            localStorage.setItem(
                'unblockee_offlineGames',
                JSON.stringify(offlineGames)
            );

            // Mirror anti-close as explicit key for centralized readers
            localStorage.setItem(
                'unblockee_antiClose',
                settings.antiClose ? 'true' : 'false'
            );

            // Persist AI settings
            localStorage.setItem('unblockee_aiTemperature', String(settings.aiTemperature || 0.7));
            localStorage.setItem('unblockee_aiAutoSave', settings.aiAutoSave ? 'true' : 'false');

            // Persist WidgetBot setting
            localStorage.setItem('unblockee_widgetbotEnabled', settings.widgetbotEnabled ? 'true' : 'false');

            // Persist movies settings
            localStorage.setItem('unblockee_maxRating', settings.maxRating || 'R');
            localStorage.setItem('unblockee_moviesProxyEnabled', settings.moviesProxyEnabled ? 'true' : 'false');

            // Persist custom panic key settings
            if (settings.customPanicKey) {
                localStorage.setItem('unblockee_customPanicKey', settings.customPanicKey);
            } else {
                localStorage.removeItem('unblockee_customPanicKey');
            }

            if (settings.customPanicUrl) {
                localStorage.setItem('unblockee_customPanicUrl', settings.customPanicUrl);
            } else {
                localStorage.removeItem('unblockee_customPanicUrl');
            }
        } catch (e) {
            console.warn('Failed to persist settings:', e);
        }

        // Apply immediate effects where appropriate
        this.applyThemePreset(settings.themePreset, settings.customBackground);
        this.applyAntiClose(!!settings.antiClose);
    }

    /**
     * Auto-save hook: recompute and persist settings when any watched control changes.
     */
    autoSaveFromEvent() {
        if (!this.isOpen) return;
        const settings = this.collectSettings();
        this.applySettings(settings);
        this.persistSettings(settings);
    }

    loadInitialState() {
        // Theme preset (supports "custom" and legacy values)
        const storedPreset = localStorage.getItem('unblockee_themePreset') || 'dark';
        const themePreset = ['dark', 'ocean', 'forest', 'custom'].includes(storedPreset)
            ? storedPreset
            : 'dark';

        // Custom background
        let customBackground = null;
        try {
            const raw = localStorage.getItem('unblockee_customBackground');
            if (raw) customBackground = JSON.parse(raw);
        } catch {
            customBackground = null;
        }

        // Global Color Thief
        const globalColorThief = localStorage.getItem('unblockee_globalColorThief') === 'true';

        // WidgetBot
        const widgetbotEnabled = localStorage.getItem('unblockee_widgetbotEnabled') !== 'false';

        // Movies settings
        const maxRating = localStorage.getItem('unblockee_maxRating') || 'R';
        const moviesProxyEnabled = localStorage.getItem('unblockee_moviesProxyEnabled') === 'true';

        // Cloaks
        const cloakMode = localStorage.getItem('unblockee_cloakMode') || 'none';

        // Panic keys
        const panicKeys = localStorage.getItem('unblockee_panicKeys') || 'none';

        // Custom panic keys
        const customPanicKey = localStorage.getItem('unblockee_customPanicKey') || null;
        const customPanicUrl = localStorage.getItem('unblockee_customPanicUrl') || null;

        // Libraries
        const primaryLibrary =
            localStorage.getItem('unblockee_primaryLibrary') || 'default';
        const altLibraryFile =
            localStorage.getItem('unblockee_altLibraryFile') || '';

        // AI settings
        const aiTemperature = parseFloat(localStorage.getItem('unblockee_aiTemperature')) || 0.7;
        const aiAutoSave = localStorage.getItem('unblockee_aiAutoSave') !== 'false'; // Default true

        // Offline
        let offlineMode = localStorage.getItem('unblockee_offlineMode');
        if (offlineMode === null) {
            // Default ON per requirements
            offlineMode = 'true';
            localStorage.setItem('unblockee_offlineMode', 'true');
        }
        const offlineModeBool = offlineMode === 'true';

        let offlineGames = [];
        try {
            const raw = localStorage.getItem('unblockee_offlineGames');
            if (raw) offlineGames = JSON.parse(raw) || [];
        } catch {
            offlineGames = [];
        }
        offlineGames = Array.isArray(offlineGames)
            ? offlineGames.slice(0, 30)
            : [];

        const antiClose =
            localStorage.getItem('unblockee_antiClose') === 'true';

        this.settings = {
            ...this.getDefaultSettings(),
            themePreset,
            customBackground,
            globalColorThief,
            cloakMode,
            panicKeys,
            customPanicKey,
            customPanicUrl,
            primaryLibrary,
            altLibraryFile,
            offlineMode: offlineModeBool,
            offlineGames,
            antiClose,
            aiTemperature,
            aiAutoSave,
            widgetbotEnabled,
            maxRating,
            moviesProxyEnabled
        };

        this.populateForm();
        this.applyThemePreset(themePreset, customBackground);
        this.applyAntiClose(antiClose);

        // Preload offline games list markup so Offline tab is instant on first open
        this.loadOfflineGamesIntoList();

        // Load cached games list
        this.loadCachedGamesIntoList();
    }

    handleOfflineGameSelectionChange(checkbox) {
        const id = checkbox.getAttribute('data-game-id');
        if (!id) return;

        let offlineGames = Array.isArray(this.settings.offlineGames)
            ? [...this.settings.offlineGames]
            : [];

        if (checkbox.checked) {
            if (!offlineGames.includes(id)) {
                if (offlineGames.length >= 30) {
                    // Enforce cap: revert checkbox
                    checkbox.checked = false;
                    if (window.notify) {
                        window.notify(
                            'You can only select up to 30 games for offline mode.',
                            'warn'
                        );
                    } else {
                        alert('You can only select up to 30 games for offline mode.');
                    }
                    return;
                }
                offlineGames.push(id);
            }
        } else {
            offlineGames = offlineGames.filter(g => g !== id);
        }

        this.settings.offlineGames = offlineGames;
        if (this.elements.offlineSelectedCount) {
            this.elements.offlineSelectedCount.textContent = offlineGames.length;
        }
    }

    applyThemePreset(presetKey, customBackground) {
        const THEME_PRESETS = {
            dark: {
                primary: '#a1a1a6',
                secondary: '#ffffff',
                background: '#0d0d0d',
                card: '#1a1a1a',
                text: '#ffffff'
            },
            ocean: {
                primary: '#3ba7ff',
                secondary: '#e0f7ff',
                background: '#02121f',
                card: '#052238',
                text: '#ffffff'
            },
            forest: {
                primary: '#4caf50',
                secondary: '#e8f5e9',
                background: '#08150b',
                card: '#0f2613',
                text: '#ffffff'
            }
        };

        const effectivePresetKey = THEME_PRESETS[presetKey] ? presetKey : 'dark';
        const preset = THEME_PRESETS[effectivePresetKey];

        const root = document.documentElement;
        root.style.setProperty('--primary-color', preset.primary);
        root.style.setProperty('--secondary-color', preset.secondary);
        root.style.setProperty('--background-color', preset.background);
        root.style.setProperty('--card-color', preset.card);
        root.style.setProperty('--text-color', preset.text);

        // Keep the theme preset select in sync even when applied programmatically.
        if (this.elements && this.elements.themePresetSelect) {
            this.elements.themePresetSelect.value = effectivePresetKey;
        }

        // If using a non-custom preset and custom color inputs exist,
        // update them for visual coherence.
        if (effectivePresetKey !== 'custom' && this.elements) {
            if (this.elements.primaryColor && this.elements.primaryColorText) {
                this.elements.primaryColor.value = preset.primary;
                this.elements.primaryColorText.value = preset.primary;
            }
            if (this.elements.secondaryColor && this.elements.secondaryColorText) {
                this.elements.secondaryColor.value = preset.secondary;
                this.elements.secondaryColorText.value = preset.secondary;
            }
            if (this.elements.bgColor && this.elements.bgColorText) {
                this.elements.bgColor.value = preset.background;
                this.elements.bgColorText.value = preset.background;
            }
            if (this.elements.textColor && this.elements.textColorText) {
                this.elements.textColor.value = preset.text;
                this.elements.textColorText.value = preset.text;
            }
        }

        // Centralized background strategy:
        // - #app-background provides base hex pattern
        // - customBackground augments via image or video
        const appBg = document.getElementById('app-background');

        // Always remove any existing dynamic video layer
        if (appBg) {
            const existingVideoLayer = appBg.querySelector('#bg-video-layer');
            if (existingVideoLayer) {
                existingVideoLayer.remove();
            }
        } else {
            // Ensure body isn't left with stale overrides
            document.body.style.backgroundImage = '';
            document.body.style.backgroundAttachment = '';
            document.body.style.backgroundSize = '';
        }

        // Default pattern: no customBackground -> clear overrides and rely on CSS.
        if (!customBackground) {
            if (appBg) {
                appBg.style.backgroundImage = '';
                appBg.style.backgroundSize = '';
                appBg.style.backgroundPosition = '';
                appBg.style.opacity = '0.9';
            } else {
                document.body.style.backgroundImage = '';
                document.body.style.backgroundAttachment = '';
                document.body.style.backgroundSize = '';
            }
            // Refresh preview chips to align with CSS vars
            this.updateThemePreviewChips();
            return;
        }

        // None preset: explicitly remove background image to show solid color only
        if (customBackground.type === 'none') {
            if (appBg) {
                appBg.style.backgroundImage = 'none';
                appBg.style.backgroundSize = '';
                appBg.style.backgroundPosition = '';
                appBg.style.opacity = '0.9';
            } else {
                document.body.style.backgroundImage = 'none';
                document.body.style.backgroundAttachment = '';
                document.body.style.backgroundSize = '';
            }
            // Refresh preview chips to align with CSS vars
            this.updateThemePreviewChips();
            return;
        }

        // Image URL: validate before applying
        if (customBackground.type === 'image' && customBackground.url && this.isLikelyImageUrl(customBackground.url)) {
            if (appBg) {
                appBg.style.backgroundImage = `url("${customBackground.url}")`;
                appBg.style.backgroundSize = 'cover';
                appBg.style.backgroundPosition = 'center center';
                appBg.style.opacity = '1';
            } else {
                document.body.style.backgroundImage = `url("${customBackground.url}")`;
                document.body.style.backgroundSize = 'cover';
                document.body.style.backgroundAttachment = 'fixed';
            }
            this.updateThemePreviewChips();
            return;
        }

        // YouTube video: extract / use videoId and inject iframe under #app-background
        if (customBackground.type === 'youtube' && customBackground.videoId) {
            if (!appBg) {
                console.warn('Custom YouTube background requested but #app-background is missing.');
                this.updateThemePreviewChips();
                return;
            }

            const vid = customBackground.videoId;
            const layer = document.createElement('iframe');
            layer.id = 'bg-video-layer';
            layer.setAttribute('title', 'Decorative background video');
            layer.setAttribute('aria-hidden', 'true');
            layer.style.position = 'fixed';
            layer.style.top = '0';
            layer.style.left = '0';
            layer.style.width = '100%';
            layer.style.height = '100%';
            layer.style.zIndex = '-1';
            layer.style.border = 'none';
            layer.style.pointerEvents = 'none';
            layer.loading = 'lazy';
            layer.referrerPolicy = 'no-referrer';
            layer.src =
                `https://www.youtube.com/embed/${vid}` +
                `?controls=0&autoplay=1&mute=1&loop=1&playlist=${vid}`;

            appBg.appendChild(layer);
            appBg.style.backgroundImage = '';
            appBg.style.opacity = '1';
        }

        // Ensure UI swatches reflect the latest theme variables.
        this.updateThemePreviewChips();
    }

    /**
     * Load available games into the Offline tab checkbox list.
     * - Reads primary/alt library settings.
     * - Renders "Loading..." while fetching.
     * - Marks games from unblockee_offlineGames as checked.
     * - Enforces MAX 30 selection visually.
     */
    async loadOfflineGamesIntoList() {
        if (!this.elements.offlineGamesList) return;

        const container = this.elements.offlineGamesList;
        container.innerHTML = '<div class="no-games">Loading games...</div>';

        // Read configured libraries from localStorage (single source of truth)
        const primary = localStorage.getItem('unblockee_primaryLibrary') || 'default';
        const alt = localStorage.getItem('unblockee_altLibraryFile') || '';

        const libraryUrls = [];
        if (primary === 'default') {
            libraryUrls.push('components/zones.json');
        } else if (primary) {
            libraryUrls.push(primary);
        }
        if (alt) {
            libraryUrls.push(alt);
        }
        if (libraryUrls.length === 0) {
            libraryUrls.push('components/zones.json');
        }

        // Load persisted offline selection (ids as strings)
        let persistedIds = [];
        try {
            const raw = localStorage.getItem('unblockee_offlineGames');
            if (raw) {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) {
                    persistedIds = parsed.map(String);
                }
            }
        } catch {
            persistedIds = [];
        }

        try {
            const allGames = [];

            for (const url of libraryUrls) {
                try {
                    const res = await fetch(url);
                    if (!res.ok) continue;
                    const data = await res.json();
                    if (Array.isArray(data)) {
                        data.forEach(g => {
                            if (!g || g.id == null) return;
                            // Avoid duplicates by id
                            if (!allGames.find(existing => String(existing.id) === String(g.id))) {
                                allGames.push(g);
                            }
                        });
                    }
                } catch {
                    // Ignore individual library failures; fall through to others
                }
            }

            if (allGames.length === 0) {
                container.innerHTML = '<div class="no-games">No games available from configured libraries.</div>';
                if (this.elements.offlineSelectedCount) {
                    this.elements.offlineSelectedCount.textContent = '0';
                }
                return;
            }

            // Render checkbox list
            const MAX = 30;
            const limitedPersisted = persistedIds.slice(0, MAX);
            const html = allGames.map(game => {
                const id = String(game.id);
                const checked = limitedPersisted.includes(id);
                const safeName = (game.name || `Game ${id}`).toString();
                return `
                    <label class="offline-game-item">
                        <input
                            type="checkbox"
                            data-game-id="${id}"
                            ${checked ? 'checked' : ''}
                        >
                        <span class="offline-game-name">${safeName}</span>
                    </label>
                `;
            }).join('');

            container.innerHTML = html;

            const selectedCount = container.querySelectorAll('input[type="checkbox"][data-game-id]:checked').length;
            if (this.elements.offlineSelectedCount) {
                this.elements.offlineSelectedCount.textContent = String(Math.min(selectedCount, MAX));
            }

            // Normalize and persist back to storage (enforce cap)
            const normalizedIds = Array.from(
                container.querySelectorAll('input[type="checkbox"][data-game-id]:checked')
            ).map(cb => cb.getAttribute('data-game-id')).slice(0, MAX);
            localStorage.setItem('unblockee_offlineGames', JSON.stringify(normalizedIds));

            // Keep settings snapshot in sync
            this.settings.offlineGames = normalizedIds;

        } catch (error) {
            console.warn('Failed to load offline games list:', error);
            container.innerHTML = '<div class="no-games">Failed to load games for offline selection.</div>';
            if (this.elements.offlineSelectedCount) {
                this.elements.offlineSelectedCount.textContent = '0';
            }
        }
    }

    open() {
        this.isOpen = true;
        
        // Ensure modal is fully initialized
        if (!this.modal) {
            console.error('Settings modal not properly initialized');
            return;
        }
        
        this.modal.classList.remove('hidden');
        document.body.classList.add('modal-open');
        this.populateForm();
        
        // Focus first input
        setTimeout(() => {
            const firstInput = this.modal.querySelector('.settings-input');
            if (firstInput) firstInput.focus();
        }, 100);
    }

    close() {
        this.isOpen = false;
        this.modal.classList.add('hidden');
        document.body.classList.remove('modal-open');
    }

    // Static method to wait for component to be ready
    static waitForReady() {
        return new Promise((resolve) => {
            const checkReady = () => {
                if (window.componentsReady && window.componentsReady.settings) {
                    resolve();
                } else {
                    setTimeout(checkReady, 100);
                }
            };
            checkReady();
        });
    }
}

SettingsModal.initSlider = function(sliderId) {
  const slider = document.getElementById(sliderId);
  if (slider) {
    slider.classList.add('slider-track');
  }
};

// Auto-initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Initialize component tracking
    window.componentsReady = window.componentsReady || {};
    
    window.SettingsModal = new SettingsModal();
    
    // Mark component as ready
    window.componentsReady.settings = true;
    window.dispatchEvent(new CustomEvent('settingsReady'));
});

// Export for module usage
function initOfflineModeUI() {
  let desc = document.getElementById('offline-mode-desc');
  if (!desc) {
    desc = document.createElement('div');
    desc.id = 'offline-mode-desc';
    document.body.appendChild(desc);
  }
  desc.textContent = "Click games to cache for offline play; cached games load from storage";
}

function addNewCloakButton(container) {
  const button = document.createElement('button');
  button.className = 'cloak-btn add-new';
  button.innerHTML = '+';
  container.appendChild(button);
  button.onclick = () => {
    const faviconUrl = prompt('Favicon URL:');
    const tabTitle = prompt('Tab title:');
    if (faviconUrl && tabTitle) {
      let cloaks = JSON.parse(localStorage.getItem('cloaks') || '[]');
      cloaks.push({faviconUrl, tabTitle});
      localStorage.setItem('cloaks', JSON.stringify(cloaks));
    }
  };
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    SettingsModal,
    addNewCloakButton
  };
}</script>

</body>
</html>
